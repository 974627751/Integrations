{
  "id": "box_content",
  "title": "Box 2.0",
  "description": "The Box Content API gives you access to secure content management and content experience features for use in your own app. It strives to be RESTful and is organized around the main resources you’re familiar with from the Box web interface.",
  "security": {
    "box_content": {
      "integration": "box_content",
      "fields": {
        "access_token": "An OAuth access token",
        "refresh_token": "An OAuth refresh token (optional)",
        "client_id": "An OAuth client ID (optional)",
        "client_secret": "An OAuth client secret (optional)"
      },
      "oauth": {
        "authorizationUrl": "https://account.box.com/api/oauth2/authorize",
        "flow": "accessCode",
        "tokenUrl": "https://api.box.com/oauth2/token",
        "type": "oauth2"
      }
    }
  },
  "logo": {
    "url": "https://api.apis.guru/v2/cache/logo/https_pbs.twimg.com_profile_images_852979584169410562_etZ6V0rx_400x400.jpg"
  },
  "tags": [
    "cloud"
  ],
  "definitions": {
    "AssignmentCounts": {
      "description": "Counts of assignments within this policy by apply-to type.",
      "properties": {
        "file": {
          "format": "int64",
          "type": "integer"
        },
        "file_version": {
          "format": "int64",
          "type": "integer"
        },
        "folder": {
          "format": "int64",
          "type": "integer"
        },
        "user": {
          "format": "int64",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "BoxFile": {
      "allOf": [
        {
          "$ref": "#/definitions/FileReference"
        },
        {
          "properties": {
            "collections": {
              "items": {
                "$ref": "#/definitions/Collection"
              },
              "type": "array"
            },
            "comment_count": {
              "description": "The number of comments on a file.",
              "format": "int64",
              "type": "integer"
            },
            "content_created_at": {
              "description": "When the content of this file was created (more info).",
              "format": "date-time",
              "type": "string"
            },
            "content_modified_at": {
              "description": "When the content of this file was last modified (more info).",
              "format": "date-time",
              "type": "string"
            },
            "created_at": {
              "description": "When this file was created on Box’s servers.",
              "format": "date-time",
              "type": "string"
            },
            "created_by": {
              "$ref": "#/definitions/UserReference",
              "description": "The user who first created file."
            },
            "description": {
              "description": "The description of this file.",
              "type": "string"
            },
            "expiring_embed_link": {
              "description": "An expiring URL for an embedded preview session in an iframe. This URL will expire after 60 seconds and the session will expire after 60 minutes.",
              "type": "string"
            },
            "extension": {
              "description": "Indicates the suffix, when available, on the file. By default, set to an empty string. The suffix usually indicates the encoding (file format) of the file contents or usage.",
              "type": "string"
            },
            "file_version": {
              "$ref": "#/definitions/FileVersionReference"
            },
            "is_package": {
              "description": "Whether the file is a package. Used for Mac Packages used by iWorks.",
              "type": "boolean"
            },
            "item_status": {
              "description": "Whether this item is deleted or not.",
              "type": "string"
            },
            "lock": {
              "$ref": "#/definitions/Lock"
            },
            "modified_at": {
              "description": "When this file was last updated on the Box servers.",
              "format": "date-time",
              "type": "string"
            },
            "modified_by": {
              "$ref": "#/definitions/UserReference",
              "description": "The user who last updated this file."
            },
            "owned_by": {
              "$ref": "#/definitions/UserReference",
              "description": "The user who owns this file."
            },
            "parent": {
              "$ref": "#/definitions/ItemReference",
              "description": "The folder containing this file."
            },
            "path_collection": {
              "$ref": "#/definitions/PathCollection",
              "description": "The path of folders to this file, starting at the root."
            },
            "permissions": {
              "$ref": "#/definitions/FilePermissions"
            },
            "purged_at": {
              "description": "When this file will be permanently deleted.",
              "format": "date-time",
              "type": "string"
            },
            "shared_link": {
              "$ref": "#/definitions/SharedLink"
            },
            "size": {
              "description": "Size of this file in bytes.",
              "format": "int64",
              "type": "integer"
            },
            "tags": {
              "description": "All tags applied to this file.",
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "trashed_at": {
              "description": "When this file was last moved to the trash.",
              "format": "date-time",
              "type": "string"
            },
            "version_number": {
              "description": "The version number of the file.",
              "type": "string"
            },
            "watermark_info": {
              "$ref": "#/definitions/WatermarkInfo"
            }
          }
        }
      ],
      "description": "File information describe file objects in Box, with attributes like who created the file, when it was last modified, and other information. The actual content of the file itself is accessible through the /files/{id}/content endpoint.",
      "title": "File Object",
      "type": "object"
    },
    "ChunkPagination": {
      "properties": {
        "chunk_size": {
          "format": "int64",
          "type": "integer"
        },
        "next_stream_position": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "Collaboration": {
      "allOf": [
        {
          "$ref": "#/definitions/Reference"
        },
        {
          "properties": {
            "accessible_by": {
              "$ref": "#/definitions/UserReference",
              "description": "The user or group who the collaboration applies to"
            },
            "acknowledged_at": {
              "description": "When the status of this collab was changed",
              "format": "date-time",
              "type": "string"
            },
            "can_view_path": {
              "description": "Whether view path collaboration feature is enabled or not. View path collaborations allow the invitee to see the entire ancestral path to the associated folder. The user will not gain privileges in any ancestral folder",
              "type": "boolean"
            },
            "created_at": {
              "description": "The time this collaboration was created",
              "format": "date-time",
              "type": "string"
            },
            "created_by": {
              "$ref": "#/definitions/UserReference",
              "description": "The user who created this collaboration"
            },
            "expires_at": {
              "description": "The time this collaboration will expire",
              "format": "date-time",
              "type": "string"
            },
            "item": {
              "$ref": "#/definitions/ItemReference"
            },
            "modified_at": {
              "description": "The time this collaboration was last modified",
              "format": "date-time",
              "type": "string"
            },
            "role": {
              "description": "The level of access this user or group has. Can be editor, viewer, previewer, uploader, previewer uploader, viewer uploader, co-owner, or owner",
              "enum": [
                "editor",
                "viewer",
                "previewer",
                "uploader",
                "previewer uploader",
                "viewer uploader",
                "co-owner",
                "owner"
              ],
              "type": "string"
            },
            "status": {
              "description": "The status of this collab. Can be accepted, pending, or rejected",
              "type": "string"
            }
          }
        }
      ],
      "description": "Collaborations are used to set and apply access permissions for users and groups to files and folders, similar to access control lists.",
      "type": "object"
    },
    "CollaborationList": {
      "allOf": [
        {
          "$ref": "#/definitions/Pagination"
        },
        {
          "properties": {
            "entries": {
              "items": {
                "$ref": "#/definitions/Collaboration"
              },
              "type": "array"
            }
          }
        }
      ],
      "type": "object"
    },
    "Collection": {
      "allOf": [
        {
          "$ref": "#/definitions/Reference"
        },
        {
          "properties": {
            "collection_type": {
              "description": "The type of the collection. This is used to determine the proper visual treatment for Box-internally created collections. Initially only “favorites” collection-type will be supported.",
              "enum": [
                "favorites"
              ],
              "type": "string"
            },
            "name": {
              "description": "The name of this collection. The only collection currently available is named “Favorites”",
              "type": "string"
            }
          }
        }
      ],
      "description": "Collections contain information about the items contained inside of them, including files and folders. The only collection available currently is a “Favorites” collection. The contents of the collection are discovered in a similar way in which the contents of a folder are discovered.",
      "title": "Collection Object",
      "type": "object"
    },
    "CollectionList": {
      "allOf": [
        {
          "$ref": "#/definitions/Pagination"
        },
        {
          "properties": {
            "entries": {
              "items": {
                "$ref": "#/definitions/Collection"
              },
              "type": "array"
            }
          }
        }
      ],
      "type": "object"
    },
    "Comment": {
      "allOf": [
        {
          "$ref": "#/definitions/Reference"
        },
        {
          "properties": {
            "created_at": {
              "description": "The time this comment was created",
              "format": "date-time",
              "type": "string"
            },
            "created_by": {
              "$ref": "#/definitions/UserReference",
              "description": "A mini user object representing the author of the comment"
            },
            "is_reply_comment": {
              "description": "Whether or not this comment is a reply to another comment",
              "type": "boolean"
            },
            "item": {
              "$ref": "#/definitions/ItemReference"
            },
            "message": {
              "description": "The comment text that the user typed",
              "type": "string"
            },
            "modified_at": {
              "description": "The time this comment was last modified",
              "format": "date-time",
              "type": "string"
            },
            "tagged_message": {
              "description": "The string representing the comment text with @mentions included. @mention format is @[id:username]. Field is not included by default.",
              "type": "string"
            }
          }
        }
      ],
      "description": "Comments are messages generated by Box users. Each message is tied to a specific file. You can create comments independently or create them as responses to other comments.\n\n\t\t\t",
      "title": "Comment Object",
      "type": "object"
    },
    "CommentList": {
      "allOf": [
        {
          "$ref": "#/definitions/Pagination"
        },
        {
          "properties": {
            "entries": {
              "items": {
                "$ref": "#/definitions/Comment"
              },
              "type": "array"
            }
          }
        }
      ],
      "type": "object"
    },
    "CopyFile": {
      "properties": {
        "name": {
          "type": "string"
        },
        "parent": {
          "properties": {
            "id": {
              "type": "string"
            }
          },
          "type": "object"
        },
        "version": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "CreateLegalHoldPolicyAssignment": {
      "description": "Request object to create a new Legal Policy Hold Assignment",
      "properties": {
        "assign_to": {
          "$ref": "#/definitions/Reference",
          "description": "Target Object. Type of target and ID of the target entity"
        },
        "policy_id": {
          "description": "ID of Policy to create Assignment for.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "CreateRetentionPolicyAssignment": {
      "description": "Request object to create a new Retention Policy Assignment",
      "properties": {
        "assign_to": {
          "$ref": "#/definitions/Reference",
          "description": "Target Object. Type of target and ID of the target entity"
        },
        "policy_id": {
          "description": "ID of Policy to create Assignment for.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "CreateTaskAssignment": {
      "properties": {
        "assign_to": {
          "$ref": "#/definitions/UserReference"
        },
        "task": {
          "$ref": "#/definitions/Task"
        }
      },
      "type": "object"
    },
    "DevicePinner": {
      "allOf": [
        {
          "$ref": "#/definitions/Reference"
        },
        {
          "properties": {
            "created_at": {
              "description": "The time this pin was created",
              "format": "date-time",
              "type": "string"
            },
            "modified_at": {
              "description": "The time this pin was modified",
              "format": "date-time",
              "type": "string"
            },
            "owned_by": {
              "$ref": "#/definitions/UserReference",
              "description": "The user that the pin belongs to"
            },
            "product_name": {
              "description": "The type of device being pinned",
              "type": "string"
            }
          }
        }
      ],
      "description": "Device pins allow enterprises to control what devices can use native Box applications. To learn more about device pinning, please see our  documentation.",
      "title": "Device Pinner Object",
      "type": "object"
    },
    "DevicePinnerList": {
      "allOf": [
        {
          "$ref": "#/definitions/Pagination"
        },
        {
          "properties": {
            "entries": {
              "items": {
                "$ref": "#/definitions/DevicePinner"
              },
              "type": "array"
            }
          }
        }
      ],
      "type": "object"
    },
    "EmailAlias": {
      "allOf": [
        {
          "$ref": "#/definitions/Reference"
        },
        {
          "properties": {
            "email": {
              "type": "string"
            },
            "is_confirmed": {
              "type": "boolean"
            }
          }
        }
      ],
      "type": "object"
    },
    "EmailAliasList": {
      "allOf": [
        {
          "$ref": "#/definitions/Pagination"
        },
        {
          "properties": {
            "entries": {
              "items": {
                "$ref": "#/definitions/EmailAlias"
              },
              "type": "array"
            }
          }
        }
      ],
      "type": "object"
    },
    "Enterprise": {
      "allOf": [
        {
          "$ref": "#/definitions/Reference"
        },
        {
          "properties": {
            "name": {
              "type": "string"
            }
          }
        }
      ],
      "description": "Mini representation of this user’s enterprise, including the ID of its enterprise.",
      "type": "object"
    },
    "Error": {
      "properties": {
        "code": {
          "type": "string"
        },
        "context_info": {
          "properties": {
            "errors": {
              "items": {
                "properties": {
                  "message": {
                    "type": "string"
                  },
                  "name": {
                    "type": "string"
                  },
                  "reason": {
                    "type": "string"
                  }
                },
                "type": "object"
              },
              "type": "array"
            }
          },
          "type": "object"
        },
        "help-url": {
          "type": "string"
        },
        "message": {
          "type": "string"
        },
        "request_id": {
          "type": "string"
        },
        "status": {
          "format": "int32",
          "type": "integer"
        },
        "type": {
          "enum": [
            "error"
          ],
          "type": "string"
        }
      },
      "type": "object"
    },
    "Event": {
      "description": "",
      "properties": {
        "additional_details": {
          "description": "This object provides additional information about the event if available. This can include how a user performed an event as well as additional information to correlate an event to external Keysafe logs. Not all events have an additional_details object.  This object is only available in the Enterprise Events.",
          "type": "object"
        },
        "created_by": {
          "$ref": "#/definitions/UserReference",
          "description": "The user that performed the action. Some events may be performed by users not logged into Box. In those instances, not all attributes of this object will be populated and the event will be attributed to a unknown user (user_id = 2)."
        },
        "event_id": {
          "description": "The id of the event, used for de-duplication purposes",
          "type": "string"
        },
        "event_type": {
          "description": "One of the event types",
          "type": "string"
        },
        "session_id": {
          "description": "The session of the user that performed the action. Not all events will populate this attribute.",
          "type": "string"
        },
        "source": {
          "description": "The object that was modified. See Object definitions for appropriate object: file, folder, comment, etc. Not all events have a source object.",
          "type": "object"
        },
        "type": {
          "enum": [
            "event"
          ],
          "type": "string"
        }
      },
      "title": "Event Object",
      "type": "object"
    },
    "EventList": {
      "allOf": [
        {
          "$ref": "#/definitions/ChunkPagination"
        },
        {
          "properties": {
            "entries": {
              "items": {
                "$ref": "#/definitions/Event"
              },
              "type": "array"
            }
          }
        }
      ],
      "type": "object"
    },
    "FilePermissions": {
      "description": "The permissions that the current user has on the file",
      "properties": {
        "can_download": {
          "type": "boolean"
        },
        "can_invite_collaborator": {
          "type": "boolean"
        },
        "can_preview": {
          "type": "boolean"
        },
        "can_rename": {
          "type": "boolean"
        },
        "can_set_share_access": {
          "type": "boolean"
        },
        "can_share": {
          "type": "boolean"
        },
        "can_upload": {
          "type": "boolean"
        },
        "cand_delete": {
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "FileReference": {
      "allOf": [
        {
          "$ref": "#/definitions/ItemReference"
        },
        {
          "properties": {
            "sha1": {
              "description": "The sha1 hash of this file.",
              "type": "string"
            }
          }
        }
      ],
      "description": "It references either a file or a folder",
      "type": "object"
    },
    "FileReferenceList": {
      "allOf": [
        {
          "$ref": "#/definitions/Pagination"
        },
        {
          "properties": {
            "entries": {
              "items": {
                "$ref": "#/definitions/FileReference"
              },
              "type": "array"
            }
          }
        }
      ],
      "type": "object"
    },
    "FileVersion": {
      "allOf": [
        {
          "$ref": "#/definitions/FileVersionReference"
        },
        {
          "properties": {
            "created_at": {
              "format": "date-time",
              "type": "string"
            },
            "modified_at": {
              "format": "date-time",
              "type": "string"
            },
            "modified_by": {
              "$ref": "#/definitions/UserReference"
            },
            "name": {
              "type": "string"
            },
            "size": {
              "format": "int64",
              "type": "integer"
            }
          }
        }
      ],
      "type": "object"
    },
    "FileVersionLegalHold": {
      "allOf": [
        {
          "$ref": "#/definitions/Reference"
        },
        {
          "properties": {
            "deleted_at": {
              "description": "Time that this File-Version-Legal-Hold was deleted.",
              "format": "date-time",
              "type": "string"
            },
            "file": {
              "$ref": "#/definitions/FileReference",
              "description": "The parent file of the File-Version that is held. Note that there is no guarantee that the current version of this File is held."
            },
            "file_version": {
              "$ref": "#/definitions/FileVersionReference",
              "description": "The File-Version that is held."
            },
            "legal_hold_policy_assignments": {
              "description": "List of assignments contributing to this Hold.",
              "items": {
                "$ref": "#/definitions/LegalHoldPolicyAssignment"
              },
              "type": "array"
            }
          }
        }
      ],
      "description": "File-Version-Legal-Hold is an entity representing all holds on a File Version. Type is legal-hold.",
      "title": "File Version Legal Hold object",
      "type": "object"
    },
    "FileVersionLegalHoldList": {
      "allOf": [
        {
          "$ref": "#/definitions/Pagination"
        },
        {
          "properties": {
            "entries": {
              "items": {
                "$ref": "#/definitions/FileVersionLegalHold"
              },
              "type": "array"
            }
          }
        }
      ],
      "type": "object"
    },
    "FileVersionList": {
      "allOf": [
        {
          "$ref": "#/definitions/Pagination"
        },
        {
          "properties": {
            "entries": {
              "items": {
                "$ref": "#/definitions/FileVersion"
              },
              "type": "array"
            }
          }
        }
      ],
      "description": "A collection of FileVersions.",
      "type": "object"
    },
    "FileVersionReference": {
      "allOf": [
        {
          "$ref": "#/definitions/Reference"
        },
        {
          "properties": {
            "sha1": {
              "description": "The sha1 hash of this file.",
              "type": "string"
            }
          }
        }
      ],
      "description": "The version information of the file.",
      "type": "object"
    },
    "FileVersionRetention": {
      "allOf": [
        {
          "$ref": "#/definitions/Reference"
        },
        {
          "properties": {
            "applied_at": {
              "description": "The time that this file version retention was created.",
              "format": "date-time",
              "type": "string"
            },
            "disposition_at": {
              "description": "The time that the retention period expires on this file version retention.",
              "format": "date-time",
              "type": "string"
            },
            "file": {
              "$ref": "#/definitions/FileReference",
              "description": "The file this file version retention was applied to."
            },
            "file_version": {
              "$ref": "#/definitions/FileVersionReference",
              "description": "The file version this file version retention was applied to."
            },
            "winning_retention_policy": {
              "$ref": "#/definitions/RetentionPolicyReference",
              "description": "The winning retention policy applied to this file_version_retention. A file version can have multiple retention policies applied."
            }
          }
        }
      ],
      "description": "A retention policy blocks permanent deletion of content for a specified amount of time. Admins can apply policies to specified folders, or an entire enterprise. A file version retention is a record for a retained file version. To use this feature, you must have the manage retention policies scope enabled for your API key via your application management console. For more information about retention policies, please visit our help documentation.\n\n\t\t\t",
      "title": "File Version Retention Object",
      "type": "object"
    },
    "FileVersionRetentionList": {
      "allOf": [
        {
          "$ref": "#/definitions/Pagination"
        },
        {
          "properties": {
            "entries": {
              "items": {
                "$ref": "#/definitions/FileVersionRetention"
              },
              "type": "array"
            }
          }
        }
      ],
      "type": "object"
    },
    "Folder": {
      "allOf": [
        {
          "$ref": "#/definitions/ItemReference"
        },
        {
          "properties": {
            "allowed_invitee_roles": {
              "description": "Folder collaboration collaboration settings allowed by the enterprise administrator.",
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "allowed_shared_link_access_levels": {
              "description": "Access level settings for shared links set by administrator. Can be collaborators, open, or company.",
              "enum": [
                "collaborators",
                "open",
                "company"
              ],
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "can_non_owners_invite": {
              "description": "Whether non-owners can invite collaborators to this folder.",
              "type": "boolean"
            },
            "collections": {
              "items": {
                "$ref": "#/definitions/Collection"
              },
              "type": "array"
            },
            "content_created_at": {
              "description": "The time the folder or its contents were originally created (according to the uploader).May be null for some folders such as root or trash.",
              "format": "date-time",
              "type": "string"
            },
            "content_modified_at": {
              "description": "The time the folder or its contents were last modified (according to the uploader).\nMay be null for some folders such as root or trash.",
              "format": "date-time",
              "type": "string"
            },
            "created_at": {
              "description": "The time the folder was created.\nMay be null for some folders such as root or trash.",
              "format": "date-time",
              "type": "string"
            },
            "created_by": {
              "$ref": "#/definitions/UserReference",
              "description": "The user who created this folder."
            },
            "description": {
              "description": "The description of the folder.",
              "type": "string"
            },
            "folder_upload_email": {
              "$ref": "#/definitions/FolderUploadEmail"
            },
            "has_collaborations": {
              "description": "Whether this folder has any collaborators.",
              "type": "boolean"
            },
            "is_externally_owned": {
              "description": "Whether this folder is owned by a user outside of the enterprise",
              "type": "boolean"
            },
            "item_collection": {
              "$ref": "#/definitions/ItemCollection"
            },
            "item_status": {
              "description": "Whether this item is deleted or not.",
              "type": "string"
            },
            "modified_by": {
              "$ref": "#/definitions/UserReference",
              "description": "The user who last modified this folder."
            },
            "owned_by": {
              "$ref": "#/definitions/UserReference",
              "description": "The user who owns this folder."
            },
            "parent": {
              "$ref": "#/definitions/ItemReference",
              "description": "The folder that contains this one.May be null for folders such as root, trash and child folders whose parent is inaccessible."
            },
            "path_collection": {
              "$ref": "#/definitions/PathCollection",
              "description": "The path of folders to this folder, starting at the root."
            },
            "permissions": {
              "$ref": "#/definitions/FolderPermissions"
            },
            "purged_at": {
              "description": "The time the folder or its contents will be purged from the trash.\nMay be null for some folders such as root or trash.",
              "format": "date-time",
              "type": "string"
            },
            "shared_link": {
              "$ref": "#/definitions/SharedLink",
              "description": "The shared link for this folder. Null if not set."
            },
            "size": {
              "description": "The folder size in bytes. Be careful parsing this integer, it can easily go into EE notation: see IEEE754 format.",
              "format": "int64",
              "type": "integer"
            },
            "sync_state": {
              "description": "Whether this folder will be synced by the Box sync clients or not. Can be synced, not_synced, or partially_synced.",
              "enum": [
                "synced",
                "not_synced",
                "partially_synced"
              ],
              "type": "string"
            },
            "tags": {
              "description": "All tags applied to this folder.",
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "trashed_at": {
              "description": "The time the folder or its contents were put in the trash.\nMay be null for some folders such as root or trash.",
              "format": "date-time",
              "type": "string"
            },
            "watermark_info": {
              "$ref": "#/definitions/WatermarkInfo"
            }
          }
        }
      ],
      "description": "Folders contain information about the items contained inside of them, including files and other folders. There is also a set of metadata such as who owns the folder and when it was modified that is also returned. When accessing other resources that make reference to folders, a ‘mini folder’ object will be used. The 'mini folder' object will return type, id, sequence_id, etag, and name.",
      "title": "Folder Object",
      "type": "object"
    },
    "FolderPermissions": {
      "description": "The permissions that the current user has on the folder",
      "properties": {
        "can_download": {
          "type": "boolean"
        },
        "can_invite_collaborator": {
          "type": "boolean"
        },
        "can_rename": {
          "type": "boolean"
        },
        "can_set_share_access": {
          "type": "boolean"
        },
        "can_share": {
          "type": "boolean"
        },
        "can_upload": {
          "type": "boolean"
        },
        "cand_delete": {
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "FolderUploadEmail": {
      "description": "The upload email address for this folder. Null if not set.",
      "properties": {
        "access": {
          "type": "string"
        },
        "email": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "Group": {
      "allOf": [
        {
          "$ref": "#/definitions/GroupReference"
        },
        {
          "properties": {
            "created_at": {
              "description": "When this groups was created on Box’s servers",
              "format": "date-time",
              "type": "string"
            },
            "description": {
              "description": "Human readable description of this Group.  This can be up to 255 characters long. Needs to be accessed via the fields parameter.",
              "type": "string"
            },
            "external_sync_identifier": {
              "description": "An arbitrary identifier that can be used by external group sync tools to link this Box Group to an external group.  Example values of this field could be an Active Directory Object ID or a Google Group ID.  We recommend use of this field in order to avoid issues when group names are updated in either Box or external systems. Needs to be accessed via the fields parameter.",
              "type": "string"
            },
            "invitability_level": {
              "description": "Specifies who can invite this group to collaborate on folders (Create Collaboration).\nadmins_only Master Admin, Coadmins, group's Group Admin.\nadmins_and_members Admins listed above and group members.\nall_managed_users All managed users in the enterprise.",
              "enum": [
                "admins_only",
                "admins_and_members",
                "all_managed_users"
              ],
              "type": "string"
            },
            "member_viewability_level": {
              "description": "Specifies who can view the members of this group (Get Memberships for Group).\nadmins_only Master Admin, Coadmins, group's Group Admin.\nadmins_and_members Admins and group members.\nall_managed_users All managed users in the enterprise.",
              "enum": [
                "admins_only",
                "admins_and_members",
                "all_managed_users"
              ],
              "type": "string"
            },
            "modified_at": {
              "description": "When this group was last updated on the Box servers",
              "format": "date-time",
              "type": "string"
            },
            "provenance": {
              "description": "Keeps track of which external source this group is coming from (e.g. \"Active Directory\", \"Google Groups\", \"Facebook Groups\").  This should be a human-readable identifier up to 255 characters long.  Setting this will also prevent Box users from editing this group directly through Box.  This is desirable for one-way syncing of groups. Needs to be accessed via the fields parameter.",
              "type": "string"
            }
          }
        }
      ],
      "description": "Groups contain a set of users, and can be used in place of users in some operations, such as collaborations.",
      "title": "Group Object",
      "type": "object"
    },
    "GroupList": {
      "allOf": [
        {
          "$ref": "#/definitions/Pagination"
        },
        {
          "properties": {
            "entries": {
              "items": {
                "$ref": "#/definitions/Group"
              },
              "type": "array"
            }
          }
        }
      ],
      "type": "object"
    },
    "GroupMembership": {
      "allOf": [
        {
          "$ref": "#/definitions/Reference"
        },
        {
          "properties": {
            "created_at": {
              "description": "The time this membership was created.",
              "format": "date-time",
              "type": "string"
            },
            "group": {
              "$ref": "#/definitions/GroupReference"
            },
            "modified_at": {
              "description": "The time this membership was last modified.",
              "format": "date-time",
              "type": "string"
            },
            "role": {
              "description": "The role of the user in the group.",
              "enum": [
                "member",
                "admin"
              ],
              "type": "string"
            },
            "user": {
              "$ref": "#/definitions/UserReference"
            }
          }
        }
      ],
      "description": "Membership is used to signify that a user is part of a group. Membership can be added, requested, updated and deleted. You can also get all members of a group, or all memberships for a given user.",
      "title": "Membership Object",
      "type": "object"
    },
    "GroupMembershipList": {
      "allOf": [
        {
          "$ref": "#/definitions/Pagination"
        },
        {
          "properties": {
            "entries": {
              "items": {
                "$ref": "#/definitions/GroupMembership"
              },
              "type": "array"
            }
          }
        }
      ],
      "type": "object"
    },
    "GroupReference": {
      "allOf": [
        {
          "$ref": "#/definitions/Reference"
        },
        {
          "properties": {
            "name": {
              "description": "The name of this group",
              "type": "string"
            }
          }
        }
      ],
      "description": "Mini representation of the group, including id and name of group.",
      "type": "object"
    },
    "Invite": {
      "allOf": [
        {
          "$ref": "#/definitions/Reference"
        },
        {
          "properties": {
            "actionable_by": {
              "$ref": "#/definitions/UserReference"
            },
            "created_at": {
              "format": "date-time",
              "type": "string"
            },
            "invited_by": {
              "$ref": "#/definitions/UserReference"
            },
            "invited_to": {
              "$ref": "#/definitions/Enterprise"
            },
            "modified_at": {
              "format": "date-time",
              "type": "string"
            },
            "status": {
              "type": "string"
            }
          }
        }
      ],
      "type": "object"
    },
    "InviteUser": {
      "properties": {
        "actionable_by": {
          "$ref": "#/definitions/UserReference"
        },
        "enterprise": {
          "$ref": "#/definitions/Reference"
        }
      },
      "type": "object"
    },
    "ItemCollection": {
      "allOf": [
        {
          "$ref": "#/definitions/Pagination"
        },
        {
          "properties": {
            "entries": {
              "items": {
                "$ref": "#/definitions/FileReference"
              },
              "type": "array"
            }
          }
        }
      ],
      "description": "A collection of mini file and folder objects contained in this folder.",
      "type": "object"
    },
    "ItemReference": {
      "allOf": [
        {
          "$ref": "#/definitions/Reference"
        },
        {
          "properties": {
            "etag": {
              "description": "A unique string identifying the version of this folder.\nMay be null for some folders such as root or trash.",
              "type": "string"
            },
            "name": {
              "description": "The name of the folder.",
              "type": "string"
            },
            "sequence_id": {
              "description": "A unique ID for use with the /events endpoint.\nMay be null for some folders such as root or trash.",
              "type": "string"
            }
          }
        }
      ],
      "description": "It references either a file or a folder",
      "type": "object"
    },
    "ItemReferenceList": {
      "allOf": [
        {
          "$ref": "#/definitions/Pagination"
        },
        {
          "properties": {
            "entries": {
              "items": {
                "$ref": "#/definitions/ItemReference"
              },
              "type": "array"
            }
          }
        }
      ],
      "type": "object"
    },
    "LegalHoldPolicy": {
      "allOf": [
        {
          "$ref": "#/definitions/Reference"
        },
        {
          "properties": {
            "assignment_count": {
              "$ref": "#/definitions/AssignmentCounts"
            },
            "created_at": {
              "description": "Time the Policy was created.",
              "format": "date-time",
              "type": "string"
            },
            "created_by": {
              "$ref": "#/definitions/UserReference",
              "description": "User who created this Policy."
            },
            "deleted_at": {
              "description": "Time that the policy release request was sent.",
              "format": "date-time",
              "type": "string"
            },
            "description": {
              "description": "The type and id of the content that is under retention. The type can either be folder or enterprise.",
              "type": "string"
            },
            "filter_ended_at": {
              "description": "User-specified, optional date filter applies to Custodian assignments only.",
              "format": "date-time",
              "type": "string"
            },
            "filter_started_at": {
              "description": "User-specified, optional date filter applies to Custodian assignments only.",
              "format": "date-time",
              "type": "string"
            },
            "modified_at": {
              "description": "Time that the Policy itself was modified. Does not update when assignments are added or removed.",
              "format": "date-time",
              "type": "string"
            },
            "policy_name": {
              "description": "Name of the Policy. This is limited to 254 characters.",
              "type": "string"
            },
            "release_notes": {
              "description": "Notes around why the policy was released. Optional property with a 500 character limit.",
              "type": "string"
            },
            "status": {
              "enum": [
                "active",
                "applying",
                "releasing",
                "released"
              ],
              "type": "string"
            }
          }
        }
      ],
      "description": "Legal Hold Policy information describes the basic characteristics of the Policy, such as name, description, and filter dates.",
      "title": "Legal Hold Policy object",
      "type": "object"
    },
    "LegalHoldPolicyAssignment": {
      "allOf": [
        {
          "$ref": "#/definitions/Reference"
        },
        {
          "properties": {
            "assigned_at": {
              "description": "Time the Assignment was created.",
              "format": "date-time",
              "type": "string"
            },
            "assigned_by": {
              "$ref": "#/definitions/UserReference",
              "description": "User who created this assignment."
            },
            "assigned_to": {
              "$ref": "#/definitions/ItemReference",
              "description": "The entity that this is assigned to. Includes type and ID."
            },
            "deleted_at": {
              "description": "Time that the Assignment release request was sent. ",
              "format": "date-time",
              "type": "string"
            },
            "legal_hold_policy": {
              "$ref": "#/definitions/RetentionPolicyReference",
              "description": "The Policy that this Assignment is part of."
            }
          }
        }
      ],
      "description": "Legal Hold Assignments are used to assign Legal Hold Policies to Custodians, Folders, Files, or File Versions. Creating a Legal Hold Assignment puts a hold on the File-Versions that belong to the Assignment's 'apply-to' entity.",
      "title": "Legal Hold Policy Assignment object",
      "type": "object"
    },
    "LegalHoldPolicyAssignmentList": {
      "allOf": [
        {
          "$ref": "#/definitions/Pagination"
        },
        {
          "properties": {
            "entries": {
              "items": {
                "$ref": "#/definitions/LegalHoldPolicyAssignment"
              },
              "type": "array"
            }
          }
        }
      ],
      "type": "object"
    },
    "LegalHoldPolicyList": {
      "allOf": [
        {
          "$ref": "#/definitions/Pagination"
        },
        {
          "properties": {
            "entries": {
              "items": {
                "$ref": "#/definitions/LegalHoldPolicy"
              },
              "type": "array"
            }
          }
        }
      ],
      "type": "object"
    },
    "Lock": {
      "allOf": [
        {
          "$ref": "#/definitions/Reference"
        },
        {
          "properties": {
            "created_at": {
              "format": "date-time",
              "type": "string"
            },
            "created_by": {
              "$ref": "#/definitions/UserReference"
            },
            "expired_at": {
              "format": "date-time",
              "type": "string"
            },
            "is_download_prevented": {
              "type": "boolean"
            }
          }
        }
      ],
      "description": "The lock held on the file.",
      "type": "object"
    },
    "MarkerPagination": {
      "properties": {
        "limit": {
          "format": "int64",
          "type": "integer"
        },
        "next_marker": {
          "type": "string"
        },
        "prev_marker": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "Metadata": {
      "additionalProperties": {
        "type": "object"
      },
      "description": "Metadata can be used for many purposes. Enterprises may want to have a better way to organize their digital assets for their marketing teams or developers may want to provide advanced content functionality such as facilitating workflows or approvals. Metadata is also visible in the Box Web Application. To learn more, please visit the help documentation.\nTemplates\nMetadata that belongs to a file/folder is grouped by templates. Templates allow the metadata service to provide a multitude of services, such as pre-defining sets of key:value pairs or schema enforcement on specific fields. For example, a marketingCollateral template may define where and when specific marketing content should be used. You can also see the representation of the template in the Box web application while navigating to a file preview. Currently, metadata associated with folders does not show in the web application.\nEach file/folder can have multiple distinct template instances associated with it, such as a marketingCollateral and retentionPolicy template instances. Template instances are also grouped by scopes. Currently, the only scopes support are enterprise and global. Enterprise scopes are defined on a per enterprises basis, whereas global scopes are Box application-wide. Attribute order within template instances is not guaranteed.\nCurrently, there are four attributes supported by templates: string, enum, float, and  date (RFC 3339).\n\nGlobal Properties Template\nIn addition to enterprise scoped templates, every file on Box has access to the global properties template. The Properties template is a bucket of free form key:value string pairs, with no additional schema associated with it. Properties are ideal for scenarios where applications want to write metadata to file objects in a flexible way, without pre-defined template structure.\nProperties follow all the conventions of standard templates, except for being located at a different endpoint. All requests made to the properties template must be made to /files/{file_id}/metadata/global/properties.",
      "title": "Metadata Object",
      "type": "object"
    },
    "MetadataList": {
      "allOf": [
        {
          "$ref": "#/definitions/Pagination"
        },
        {
          "properties": {
            "entries": {
              "items": {
                "$ref": "#/definitions/Metadata"
              },
              "type": "array"
            }
          }
        }
      ],
      "description": "A collection of Metadata objects",
      "type": "object"
    },
    "MetadataTemplate": {
      "description": "Metadata that belongs to a file or folder is grouped by templates. Templates allow the metadata service to provide a multitude of services, such as pre-defining sets of key:value pairs or schema enforcement on specific fields.",
      "properties": {
        "displayName": {
          "description": "The display name of the template. The character limit is 4096.",
          "type": "string"
        },
        "fields": {
          "description": "The ordered set of key:value pairs for the template.",
          "items": {
            "$ref": "#/definitions/TemplateFields"
          },
          "type": "array"
        },
        "hidden": {
          "description": "Whether this template is hidden in the UI",
          "type": "boolean"
        },
        "scope": {
          "description": "The scope of the object.",
          "enum": [
            "enterprise",
            "global"
          ],
          "type": "string"
        },
        "templateKey": {
          "description": "A unique identifier for the template. The identifier must be unique across the scope of the enterprise to which the metadata template is being applied to. Defaults to a string derived from the displayName if no value is provided.",
          "type": "string"
        }
      },
      "title": "Metadata Template Object",
      "type": "object"
    },
    "MetadataTemplateList": {
      "allOf": [
        {
          "$ref": "#/definitions/MarkerPagination"
        },
        {
          "properties": {
            "entries": {
              "items": {
                "$ref": "#/definitions/MetadataTemplate"
              },
              "type": "array"
            }
          }
        }
      ],
      "description": "A collection Metadata templates",
      "type": "object"
    },
    "ObjectList": {
      "allOf": [
        {
          "$ref": "#/definitions/Pagination"
        },
        {
          "properties": {
            "entries": {
              "items": {
                "type": "object"
              },
              "type": "array"
            }
          }
        }
      ],
      "type": "object"
    },
    "Pagination": {
      "properties": {
        "limit": {
          "format": "int64",
          "type": "integer"
        },
        "offset": {
          "format": "int64",
          "type": "integer"
        },
        "order": {
          "items": {
            "properties": {
              "by": {
                "type": "string"
              },
              "direction": {
                "type": "string"
              }
            },
            "type": "object"
          },
          "type": "array"
        },
        "total_count": {
          "format": "int64",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "PathCollection": {
      "allOf": [
        {
          "$ref": "#/definitions/Pagination"
        },
        {
          "properties": {
            "entries": {
              "items": {
                "$ref": "#/definitions/ItemReference"
              },
              "type": "array"
            }
          }
        }
      ],
      "description": "The path of folders, starting at the root.",
      "type": "object"
    },
    "RealtimeServer": {
      "properties": {
        "max_retries": {
          "format": "int64",
          "type": "integer"
        },
        "retry_timeout": {
          "format": "int64",
          "type": "integer"
        },
        "ttl": {
          "format": "int64",
          "type": "integer"
        },
        "type": {
          "type": "string"
        },
        "url": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "RealtimeServerList": {
      "allOf": [
        {
          "$ref": "#/definitions/ChunkPagination"
        },
        {
          "properties": {
            "entries": {
              "items": {
                "$ref": "#/definitions/RealtimeServer"
              },
              "type": "array"
            }
          }
        }
      ],
      "type": "object"
    },
    "Reference": {
      "properties": {
        "id": {
          "type": "string"
        },
        "type": {
          "enum": [
            "folder",
            "file",
            "user",
            "file_version",
            "lock",
            "collaboration",
            "comment",
            "task",
            "web_link",
            "collection",
            "task_assignment",
            "event",
            "realtime_server",
            "webhook_event",
            "webhook",
            "enterprise",
            "invite",
            "email_alias",
            "group",
            "group_membership",
            "device_pinner",
            "retention_policy",
            "retention_policy_assignment",
            "file_version_retention",
            "legal_hold_policy",
            "legal_hold_policy_assignment",
            "legal_hold"
          ],
          "type": "string"
        }
      },
      "type": "object"
    },
    "RetentionPolicy": {
      "allOf": [
        {
          "$ref": "#/definitions/RetentionPolicyReference"
        },
        {
          "properties": {
            "created_at": {
              "description": "The time that the retention policy was created.",
              "format": "date-time",
              "type": "string"
            },
            "created_by": {
              "$ref": "#/definitions/UserReference",
              "description": "A mini user object representing the user that created the retention policy."
            },
            "disposition_action": {
              "description": "The disposition action of the retention policy. This actioncan be permanently_delete, which will cause the content retained by the policy to be permanently deleted, or remove_retention, which will lift the retention policy from the content, allowing it to be deleted by users, once the retention policy time period has passed.",
              "enum": [
                "permanently_delete",
                "remove_retention"
              ],
              "type": "string"
            },
            "modified_at": {
              "description": "The time that the retention policy was last modified.",
              "format": "date-time",
              "type": "string"
            },
            "policy_type": {
              "description": "The type of the retention policy. A retention policy type can either be finite, where a specific amount of time to retain the content is known upfront, or indefinite, where the amount of time to retain the content is still unknown.",
              "enum": [
                "finite",
                "indefinite"
              ],
              "type": "string"
            },
            "retention_length": {
              "description": "The length of the retention policy. This length specifies the duration in days that the retention policy will beactive for after being assigned to content.",
              "format": "int64",
              "type": "integer"
            },
            "status": {
              "description": "The status of a retention policy. The status of a policy will be active, unless explicitly retired by an administrator, in which case the status will be retired. Once a policyhas been retired, it cannot become active again.",
              "enum": [
                "active",
                "retired"
              ],
              "type": "string"
            }
          }
        }
      ],
      "description": "A retention policy blocks permanent deletion of content for a specified amount of time. Admins can create retention policies and then later assign them to specific folders or their entire enterprise.  To use this feature, you must have the manage retention policies scope enabled for your API key via your application management console. For more information about retention policies, please visit our help documentation. \n\n\t\t\t",
      "title": "Retention Policy Object",
      "type": "object"
    },
    "RetentionPolicyAssignment": {
      "allOf": [
        {
          "$ref": "#/definitions/Reference"
        },
        {
          "properties": {
            "assigned_at": {
              "description": "The time that the retention policy assignment was created.",
              "format": "date-time",
              "type": "string"
            },
            "assigned_by": {
              "$ref": "#/definitions/UserReference",
              "description": "A mini user object representing the user that created the retention policy assignment."
            },
            "assigned_to": {
              "$ref": "#/definitions/ItemReference",
              "description": "The type and id of the content that is under retention. The type can either be folder or enterprise."
            },
            "retention_policy": {
              "$ref": "#/definitions/RetentionPolicyReference",
              "description": "A mini retention policy object representing the retention policy that has been assigned to this content."
            }
          }
        }
      ],
      "description": "The retention policy assignment endpoint provides a way for admins to apply a retention policy on a per-folder basis, or place a blanket policy over the entire enterprise.\n\n\t\t\t",
      "title": "Retention Policy Assignment Object",
      "type": "object"
    },
    "RetentionPolicyAssignmentList": {
      "properties": {
        "entries": {
          "items": {
            "$ref": "#/definitions/RetentionPolicyAssignment"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "RetentionPolicyList": {
      "properties": {
        "entries": {
          "items": {
            "$ref": "#/definitions/RetentionPolicy"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "RetentionPolicyReference": {
      "allOf": [
        {
          "$ref": "#/definitions/Reference"
        },
        {
          "properties": {
            "policy_name": {
              "description": "The name given to the retention policy",
              "type": "string"
            }
          }
        }
      ],
      "description": "Mini representation of the retention policy",
      "type": "object"
    },
    "SharedLink": {
      "properties": {
        "access": {
          "type": "string"
        },
        "download_count": {
          "format": "int64",
          "type": "integer"
        },
        "download_url": {
          "type": "string"
        },
        "effective_access": {
          "type": "string"
        },
        "is_password_enabled": {
          "type": "boolean"
        },
        "password": {
          "type": "string"
        },
        "permissions": {
          "$ref": "#/definitions/SharedLinkPermissions"
        },
        "preview_count": {
          "format": "int64",
          "type": "integer"
        },
        "unshared_at": {
          "type": "string"
        },
        "url": {
          "type": "string"
        },
        "vanity_url": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "SharedLinkPermissions": {
      "properties": {
        "can_download": {
          "type": "boolean"
        },
        "can_preview": {
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "Task": {
      "allOf": [
        {
          "$ref": "#/definitions/Reference"
        },
        {
          "properties": {
            "action": {
              "description": "The action the task assignee will be prompted to do. Must be review",
              "enum": [
                "review"
              ],
              "type": "string"
            },
            "created_at": {
              "description": "When this task was created",
              "format": "date-time",
              "type": "string"
            },
            "created_by": {
              "$ref": "#/definitions/UserReference",
              "description": "The user who created this task"
            },
            "due_at": {
              "description": "The date at which this task is due",
              "format": "date-time",
              "type": "string"
            },
            "is_completed": {
              "description": "Whether or not this task has been completed",
              "type": "boolean"
            },
            "item": {
              "$ref": "#/definitions/FileReference"
            },
            "message": {
              "description": "A message that will be included with this task",
              "type": "string"
            },
            "task_assignment_collection": {
              "$ref": "#/definitions/TaskAssignmentList"
            }
          }
        }
      ],
      "description": "Tasks enabled file-centric workflows in Box. User can create tasks on files and assign them to collaborators on Box. You can read more about tasks in Box here.\n\n\t\t\t",
      "title": "Task Object",
      "type": "object"
    },
    "TaskAssignment": {
      "allOf": [
        {
          "$ref": "#/definitions/Reference"
        },
        {
          "properties": {
            "assigned_at": {
              "description": "The date at which this task assignment was assigned",
              "format": "date-time",
              "type": "string"
            },
            "assigned_by": {
              "$ref": "#/definitions/UserReference",
              "description": "The user who assigned this task assignment"
            },
            "assigned_to": {
              "$ref": "#/definitions/UserReference"
            },
            "completed_at": {
              "description": "The date at which this task assignment was completed",
              "format": "date-time",
              "type": "string"
            },
            "item": {
              "$ref": "#/definitions/FileReference"
            },
            "message": {
              "description": "A message that will be included with this task assignment",
              "type": "string"
            },
            "reminded_at": {
              "description": "The date at which this task assignment was reminded",
              "format": "date-time",
              "type": "string"
            },
            "resolution_state": {
              "description": "State of this assignment (complete/incomplete)",
              "enum": [
                "completed",
                "incomplete",
                "approved",
                "rejected"
              ],
              "type": "string"
            }
          }
        }
      ],
      "type": "object"
    },
    "TaskAssignmentList": {
      "allOf": [
        {
          "$ref": "#/definitions/Pagination"
        },
        {
          "properties": {
            "entries": {
              "items": {
                "$ref": "#/definitions/TaskAssignment"
              },
              "type": "array"
            }
          }
        }
      ],
      "description": "A collection Task Assignment.",
      "type": "object"
    },
    "TaskList": {
      "allOf": [
        {
          "$ref": "#/definitions/Pagination"
        },
        {
          "properties": {
            "entries": {
              "items": {
                "$ref": "#/definitions/Task"
              },
              "type": "array"
            }
          }
        }
      ],
      "description": "A collection Tasks.",
      "type": "object"
    },
    "TemplateFields": {
      "properties": {
        "description": {
          "description": "A description of the field. The character limit is 4096. All characters are allowed.",
          "type": "string"
        },
        "displayName": {
          "description": "The display name of the field. The character limit is 4096. All characters are allowed.",
          "type": "string"
        },
        "hidden": {
          "type": "boolean"
        },
        "key": {
          "description": "A unique identifier for the field. The identifier must be unique within the template to which it belongs. The character limit is 256. All characters are allowed.",
          "type": "string"
        },
        "options": {
          "items": {
            "properties": {
              "key": {
                "type": "string"
              }
            },
            "type": "object"
          },
          "type": "array"
        },
        "type": {
          "description": "The data type of the field's value.",
          "enum": [
            "string",
            "enum",
            "float",
            "date"
          ],
          "type": "string"
        }
      },
      "type": "object"
    },
    "UpdateMetadata": {
      "items": {
        "properties": {
          "from": {
            "description": "Required for move or copy. The path that designates the source key, in the format of a JSON-Pointer, formatted in the same way as path. Used in conjunction with path: from specifies the source, path specifies the destination.",
            "type": "string"
          },
          "op": {
            "description": "The operation type. Must be add, replace, remove , test, move, or copy.",
            "enum": [
              "add",
              "replace",
              "remove",
              "test",
              "move",
              "copy"
            ],
            "type": "string"
          },
          "path": {
            "description": "The path that designates the key, in the format of a JSON-Pointer. Since all keys are located at the root of the metadata instance, the key must be prefixed with a /. Special characters ~ and / in the key must be escaped according to JSON-Pointer specification. The value at the path must exist for the operation to be successful.",
            "type": "string"
          },
          "value": {
            "description": "The value to be set or tested. Required for add, replace, and test operations. For add, if value already exists, then previous value will be overwritten by the new value. For replace, the metadata value must exist before replacing.For test, the value of the existing metadata instance must match the specified value.",
            "type": "string"
          }
        },
        "required": [
          "op",
          "path"
        ],
        "type": "object"
      },
      "type": "array"
    },
    "UpdateMetadataTemplate": {
      "items": {
        "properties": {
          "data": {
            "description": "The data for the operation.  Can vary depending on the operation.",
            "type": "object"
          },
          "enumOptionKeys": {
            "description": "For operations that affect multiple enum options, the keys of the enum options to be affected.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "fieldKey": {
            "description": "For operations that affect a specific field, the key of the field to be affected.",
            "type": "string"
          },
          "fieldKeys": {
            "description": "For operations that affect multiple fields, the keys of the fields to be affected.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "op": {
            "description": "The operation name.",
            "enum": [
              "addEnumOption",
              "addField",
              "editField",
              "editTemplate",
              "reorderEnumOptions",
              "reorderFields"
            ],
            "type": "string"
          }
        },
        "required": [
          "op"
        ],
        "type": "object"
      },
      "type": "array"
    },
    "User": {
      "allOf": [
        {
          "$ref": "#/definitions/UserReference"
        },
        {
          "properties": {
            "address": {
              "description": "The user’s address.",
              "type": "string"
            },
            "avatar_url": {
              "description": "URL of this user’s avatar image.",
              "type": "string"
            },
            "can_see_managed_users": {
              "description": "Whether this user can see other enterprise users in her contact list.",
              "type": "boolean"
            },
            "created_at": {
              "description": "The time this user was created.",
              "format": "date-time",
              "type": "string"
            },
            "enterprise": {
              "$ref": "#/definitions/Enterprise"
            },
            "hostname": {
              "description": "The root (protocol, subdomain, domain) of any links that need to be generated for this user",
              "type": "string"
            },
            "is_exempt_from_device_limits": {
              "description": "Whether to exempt this user from Enterprise device limits.",
              "type": "boolean"
            },
            "is_exempt_from_login_verification": {
              "description": "Whether or not this user must use two-factor authentication.",
              "type": "boolean"
            },
            "is_external_collab_restricted": {
              "description": "Whether this user is allowed to collaborate with users outside her enterprise.",
              "type": "boolean"
            },
            "is_sync_enabled": {
              "description": "Whether or not this user can use Box Sync.",
              "type": "boolean"
            },
            "job_title": {
              "description": "The user’s job title.",
              "type": "string"
            },
            "language": {
              "description": "The language of this user. (ISO 639-1 Language Code)",
              "type": "string"
            },
            "max_upload_size": {
              "description": "The maximum individual file size in bytes this user can have.",
              "format": "int64",
              "type": "integer"
            },
            "modified_at": {
              "description": "The time this user was last modified.",
              "format": "date-time",
              "type": "string"
            },
            "my_tags": {
              "description": "Tags for all files and folders owned by this user.",
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "phone": {
              "description": "The user’s phone number.",
              "type": "string"
            },
            "role": {
              "description": "This user’s enterprise role. Can be admin, coadmin, or user.",
              "enum": [
                "admin",
                "coadmin",
                "user"
              ],
              "type": "string"
            },
            "space_amount": {
              "description": "The user’s total available space amount in bytes.",
              "format": "int64",
              "type": "integer"
            },
            "space_used": {
              "description": "The amount of space in use by the user.",
              "format": "int64",
              "type": "integer"
            },
            "status": {
              "description": "Can be active, inactive, cannot_delete_edit, or cannot_delete_edit_upload.",
              "enum": [
                "active",
                "inactive",
                "cannot_delete_edit",
                "cannot_delete_edit_upload"
              ],
              "type": "string"
            },
            "timezone": {
              "description": "The timezone of this user. (tz Database timezones)",
              "type": "string"
            },
            "tracking_codes": {
              "description": "An array of key/value pairs set by the user’s admin.",
              "items": {
                "type": "object"
              },
              "type": "array"
            }
          }
        }
      ],
      "description": "The users endpoint is used for managing a user and its content. For an individual user, this includes their own user information and content. For an enterprise admin, this includes both the individual user and any other users in the admin’s enterprise account.",
      "title": "User Object",
      "type": "object"
    },
    "UserList": {
      "allOf": [
        {
          "$ref": "#/definitions/Pagination"
        },
        {
          "properties": {
            "entries": {
              "items": {
                "$ref": "#/definitions/User"
              },
              "type": "array"
            }
          }
        }
      ],
      "type": "object"
    },
    "UserReference": {
      "description": "It references a user",
      "properties": {
        "id": {
          "description": "Unqiue string identifying this user.",
          "type": "string"
        },
        "login": {
          "description": "The email address this user uses to login.",
          "type": "string"
        },
        "name": {
          "description": "Name of this user",
          "type": "string"
        },
        "type": {
          "enum": [
            "user"
          ],
          "type": "string"
        }
      },
      "type": "object"
    },
    "Watermark": {
      "properties": {
        "watermark": {
          "$ref": "#/definitions/WatermarkReference"
        }
      },
      "type": "object"
    },
    "WatermarkInfo": {
      "items": {
        "properties": {
          "is_watermarked": {
            "type": "boolean"
          }
        }
      },
      "type": "array"
    },
    "WatermarkReference": {
      "description": "Waternmark a semi-transparent overlay on an embedded file preview that displays a viewer's email address or user ID and the time of access over a file's content",
      "properties": {
        "created_at": {
          "description": "When this watermark was created",
          "format": "date-time",
          "type": "string"
        },
        "imprint": {
          "enum": [
            "default"
          ],
          "type": "string"
        },
        "modified_at": {
          "description": "When this task was modified",
          "format": "date-time",
          "type": "string"
        }
      },
      "type": "object"
    },
    "WebLink": {
      "allOf": [
        {
          "$ref": "#/definitions/ItemReference"
        },
        {
          "properties": {
            "created_at": {
              "description": "When this file was created on Box’s servers.",
              "format": "date-time",
              "type": "string"
            },
            "created_by": {
              "$ref": "#/definitions/UserReference",
              "description": "The user who first created file."
            },
            "description": {
              "description": "The description accompanying the web link. This is visible within the Box web application.",
              "type": "string"
            },
            "item_status": {
              "description": "Whether this item is deleted or not.",
              "type": "string"
            },
            "modified_at": {
              "description": "When this file was last updated on the Box servers.",
              "format": "date-time",
              "type": "string"
            },
            "modified_by": {
              "$ref": "#/definitions/UserReference",
              "description": "The user who last updated this file."
            },
            "owned_by": {
              "$ref": "#/definitions/UserReference",
              "description": "The user who owns this file."
            },
            "parent": {
              "$ref": "#/definitions/ItemReference",
              "description": "The parent object the web link belongs to"
            },
            "path_collection": {
              "$ref": "#/definitions/PathCollection",
              "description": "The path of folders to this item, starting at the root."
            },
            "purged_at": {
              "description": "When this file will be permanently deleted.",
              "format": "date-time",
              "type": "string"
            },
            "shared_link": {
              "$ref": "#/definitions/SharedLink",
              "description": "The shared link object for this file."
            },
            "trashed_at": {
              "description": "When this file was last moved to the trash.",
              "format": "date-time",
              "type": "string"
            },
            "url": {
              "description": "The URL this web link points to.",
              "type": "string"
            }
          }
        }
      ],
      "description": "Web links are objects that point to URLs. These objects are also known as bookmarks within the Box web application. Web link objects are treated similarly to file objects, so they will also support shared links, copy, permanent delete, and restore with the format /web_links/{WEB_LINK_ID} in place of /files/{FILE_ID}.",
      "title": "Web Link Object",
      "type": "object"
    },
    "Webhook": {
      "allOf": [
        {
          "$ref": "#/definitions/Reference"
        },
        {
          "properties": {
            "address": {
              "description": "The notification URL of the webhook. The notification URL is the URL used by Box to send a notification when the webhook is triggered.",
              "type": "string"
            },
            "created_at": {
              "description": "An RFC-3339 timestamp identifying the time that the webhook was created.",
              "format": "date-time",
              "type": "string"
            },
            "created_by": {
              "$ref": "#/definitions/UserReference"
            },
            "target": {
              "$ref": "#/definitions/Reference",
              "description": "A target is a file or folder"
            },
            "triggers": {
              "description": "An array of event names. The events that webhooks support are listed in the 'Event Triggers' (https://docs.box.com/reference#event-triggers) section.",
              "items": {
                "type": "string"
              },
              "type": "array"
            }
          }
        }
      ],
      "description": "When you create or retrieve a webhook a JSON object representing the webhook is returned to you. This JSON object's fields contain the name and ID of the webhook, along with configuration details such as its target and its notification URL.",
      "title": "Webhook Object",
      "type": "object"
    },
    "WebhookList": {
      "allOf": [
        {
          "$ref": "#/definitions/Pagination"
        },
        {
          "properties": {
            "entries": {
              "items": {
                "$ref": "#/definitions/Webhook"
              },
              "type": "array"
            }
          }
        }
      ],
      "type": "object"
    }
  },
  "actions": [
    {
      "id": "getPendingCollaborations",
      "title": "getPendingCollaborations",
      "description": "Used to retrieve all pending collaboration invites for this user.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "fields": {
            "type": "string",
            "description": "Attribute(s) to include in the response"
          },
          "status": {
            "type": "string",
            "description": "Must be 'pending'",
            "enum": [
              "pending"
            ]
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/CollaborationList"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "createCollaboration",
      "title": "createCollaboration",
      "description": "Used to add a collaboration for a single user or a single group to a folder. Either an email address, a user ID, or a group id can be used to create the collaboration. If the collaboration is being created with a group, access to this endpoint is granted based on the group's invitability_level.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "body": {
            "$ref": "#/definitions/Collaboration"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/Collaboration"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "deleteCollaboration",
      "title": "deleteCollaboration",
      "description": "Used to delete a single collaboration.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "COLLAB_ID": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {},
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "getCollaboration",
      "title": "getCollaboration",
      "description": "Used to get information about a single collaboration. All collaborations for a single folder can be retrieved through GET /folders/{id}/collaborations. A complete list of the user’s pending collaborations can also be retrieved.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "COLLAB_ID": {
            "type": "string"
          },
          "fields": {
            "type": "string",
            "description": "Attribute(s) to include in the response"
          },
          "status": {
            "type": "string",
            "description": "Can only be pending",
            "enum": [
              "pending"
            ]
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/Collaboration"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "updateCollaboation",
      "title": "updateCollaboation",
      "description": "Used to edit an existing collaboration. Descriptions of the various roles can be found here.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "COLLAB_ID": {
            "type": "string"
          },
          "body": {
            "$ref": "#/definitions/Collaboration"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/Collaboration"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "getCollections",
      "title": "getCollections",
      "description": "Retrieves the collections for the given user. Currently, only the favorites collection is supported.",
      "inputSchema": {},
      "outputSchema": {
        "$ref": "#/definitions/CollectionList"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "getCollectionItems",
      "title": "getCollectionItems",
      "description": "Retrieves the files and/or folders contained within this collection. Collection item lists behave a lot like getting a folder’s items.\nPaginated results can be retrieved using the limit and offset parameters.\nSub-object fields can be requested via the ?fields parameter",
      "inputSchema": {
        "type": "object",
        "properties": {
          "COLLECTION_ID": {
            "type": "string"
          },
          "fields": {
            "type": "string",
            "description": "Attribute(s) to include in the response"
          },
          "limit": {
            "type": "integer",
            "format": "int64",
            "description": "The maximum number of items to return in a page."
          },
          "offset": {
            "type": "string",
            "description": "The offset at which to begin the response. An offset of value of 0 will start at the beginning of the folder-listing. Offset of 2 would start at the 2nd record, not the second page. Note: If there are hidden items in your previous response, your next offset should be = offset + limit, not the # of records you received back."
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/ItemReferenceList"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "createComment",
      "title": "createComment",
      "description": "Used to add a comment by the user to a specific file or comment (i.e. as a reply comment).",
      "inputSchema": {
        "type": "object",
        "properties": {
          "fields": {
            "type": "string",
            "description": "Attribute(s) to include in the response."
          },
          "body": {
            "$ref": "#/definitions/Comment"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/Comment"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "deleteComment",
      "title": "deleteComment",
      "description": "Permanently deletes a comment.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "COMMENT_ID": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {},
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "getComment",
      "title": "getComment",
      "description": "Used to retrieve the message and metadata about a specific comment. Information about the user who created the comment is also included.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "COMMENT_ID": {
            "type": "string"
          },
          "fields": {
            "type": "string",
            "description": "Attribute(s) to include in the response."
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/Comment"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "updateComment",
      "title": "updateComment",
      "description": "Used to update the message of the comment.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "COMMENT_ID": {
            "type": "string"
          },
          "fields": {
            "type": "string",
            "description": "Attribute(s) to include in the response."
          },
          "body": {
            "$ref": "#/definitions/Comment"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/Comment"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "deleteDevicePin",
      "title": "deleteDevicePin",
      "description": "Delete individual device pin.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "ID": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {},
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "getDevicePin",
      "title": "getDevicePin",
      "description": "Gets information about an individual device pin.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "ID": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/DevicePinner"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "getEnterpriseDevicePins",
      "title": "getEnterpriseDevicePins",
      "description": "Gets all the device pins within a given enterprise. Must be an enterprise admin with the manage enterprise scope to make this call.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "ENTERPRISE_ID": {
            "type": "string"
          },
          "marker": {
            "type": "string",
            "description": "Needs not be passed or can be empty for first invocation of the API. Use the one returned in response for each subsequent call."
          },
          "limit": {
            "type": "string",
            "description": "Default value is 100. Max value is 10000"
          },
          "direction": {
            "type": "string",
            "description": "Default is \"asc\". Valid values are asc, desc. Case in-sensitive, ASC/DESC works just fine."
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/DevicePinnerList"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "getUserEvents",
      "title": "getUserEvents",
      "description": "Use this to get events for a given user. A chunk of event objects is returned for the user based on the parameters passed in. Parameters indicating how many chunks are left as well as the next stream_position are also returned.\n\nTo retrieve Enterprise Events specify 'stream_type=admin_logs'. Retrieves up to a year' events for all users in an enterprise. Upper and lower bounds as well as filters can be applied to the results.",
      "inputSchema": {
        "type": [
          "object",
          "null"
        ],
        "properties": {
          "stream_position": {
            "type": "string",
            "description": "The location in the event stream at which you want to start receiving events. Can specify special case ‘now’ to get 0 events and the latest stream position for initialization."
          },
          "stream_type": {
            "type": "string",
            "description": "Limits the type of events returned: all: returns everything, changes: returns tree changes, sync: returns tree changes only for sync folders",
            "enum": [
              "all",
              "changes",
              "sync",
              "admin_logs"
            ]
          },
          "limit": {
            "type": "integer",
            "format": "int64",
            "description": "Limits the number of events returned"
          },
          "event_type": {
            "type": "string",
            "description": "A comma-separated list of events to filter by"
          },
          "created_after": {
            "type": "string",
            "format": "date-time",
            "description": "A lower bound on the timestamp of the events returned"
          },
          "created_before": {
            "type": "string",
            "format": "date-time",
            "description": "An upper bound on the timestamp of the events returned"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/EventList"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "eventLongPolling",
      "title": "eventLongPolling",
      "description": "To get real-time notification of activity in a Box account, use the long poll feature of the /events API. To do so, first call the /events API with an OPTIONS call to retrieve the long poll URL to use. Next, make a GET request to the provided URL to begin listening for events. If an event occurs within an account you are monitoring, you will receive a response with the value new_change. It’s important to note that this response will not come with any other details, but should serve as a prompt to take further action such as calling the /events endpoint with your last known stream_position. After sending this response, the server will close the connection and you will need to repeat the long poll process to begin listening for events again.\nIf no events occur for a period of time after you make the GET request to the long poll URL, you will receive a response with the value reconnect. When you receive this response, you’ll make another OPTIONS call to the /events endpoint and repeat the long poll process.\nIf you receive no events in retry_timeout seconds, you should make another GET request to the real time server (i.e. URL in the response). This might be necessary in case you do not receive the reconnect message in the face of network errors.\nIf you receive max_retries error when making GET requests to the real time server, you should make another OPTIONS request.",
      "inputSchema": {},
      "outputSchema": {
        "$ref": "#/definitions/RealtimeServerList"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "getFileVersionLegalHoldPolicies",
      "title": "getFileVersionLegalHoldPolicies",
      "description": "Get list of non-deleted Holds for a single Policy.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "policy_id": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/FileVersionLegalHoldList"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "getFileVersionLegalHoldPolicy",
      "title": "getFileVersionLegalHoldPolicy",
      "description": "Get details of a single File Version Legal Hold.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "ID": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/FileVersionLegalHold"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "getFileVersionRetentions",
      "title": "getFileVersionRetentions",
      "description": "Retrieves all file version retentions for the given enterprise.",
      "inputSchema": {
        "type": [
          "object",
          "null"
        ],
        "properties": {
          "file_id": {
            "type": "string",
            "description": "A file id to filter the file version retentions by."
          },
          "file_version_id": {
            "type": "string",
            "description": "A file version id to filter the file version retentions by."
          },
          "policy_id": {
            "type": "string",
            "description": "A policy id to filter the file version retentions by."
          },
          "disposition_action": {
            "type": "string",
            "description": "The disposition action of the retention policy. This action can be permanently_delete, which will cause the content retained by the policy to be permanently deleted, or remove_retention, which will lift the retention policy from the content, allowing it to be deleted by users, once the retention policy time period has passed.",
            "enum": [
              "permanently_delete",
              "remove_retention"
            ]
          },
          "disposition_before": {
            "type": "string",
            "description": "See content times for formatting"
          },
          "disposition_after": {
            "type": "string",
            "description": "See content times for formatting"
          },
          "limit": {
            "type": "integer",
            "format": "int64",
            "description": "The maximum number of items to return in a page"
          },
          "marker": {
            "type": "string",
            "description": "Base 64 encoded string that represents where the paging should being. It should be left blank to begin paging."
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/FileVersionRetentionList"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "getFileVersionRetention",
      "title": "getFileVersionRetention",
      "description": "Used to retrieve information about a file version retention",
      "inputSchema": {
        "type": "object",
        "properties": {
          "FILE_VERSION_RETENTION_ID": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/FileVersionRetention"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "fileUploadPreflightCheck",
      "title": "fileUploadPreflightCheck",
      "description": "The Pre-flight check API will verify that a file will be accepted by Box before you send all the bytes over the wire.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "body": {
            "$ref": "#/definitions/BoxFile"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {},
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "deleteFile",
      "title": "deleteFile",
      "description": "Discards a file to the trash. The etag of the file can be included as an ‘If-Match’ header to prevent race conditions.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "FILE_ID": {
            "type": "string"
          },
          "If-Match": {
            "type": "string",
            "description": "The etag of the file. This is in the ‘etag’ field of the file object."
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {},
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "getFile",
      "title": "getFile",
      "description": "Used to retrieve the metadata about a file.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "FILE_ID": {
            "type": "string"
          },
          "fields": {
            "type": "string",
            "description": "Attribute(s) to include in the response."
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/BoxFile"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "restoreTrashedFile",
      "title": "restoreTrashedFile",
      "description": "Restores an item that has been moved to the trash. Default behavior is to restore the item to the folder it was in before it was moved to the trash. If that parent folder no longer exists or if there is now an item with the same name in that parent folder, the new parent folder and/or new name will need to be included in the request.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "FILE_ID": {
            "type": "string"
          },
          "body": {
            "$ref": "#/definitions/BoxFile"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/BoxFile"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "updateFileInfo",
      "title": "updateFileInfo",
      "description": "Used to update individual or multiple fields in the file object, including renaming the file, changing its description, and creating a shared link for the file. To move a file, change the ID of its parent folder. An optional If-Match header can be included to prevent race conditions.\n\nTo lock and unlock files, you execute a PUT operation on the /files/{file id} endpoint and set or clear the lock properties on the file.\n\nUsed to create a shared link for this particular file. Please see here for more information on the permissions available for shared links. In order to get default shared link status, set it to an empty access level, i.e. {\"shared_link\": {}}. In order to disable a shared link, send this same type of PUT request with the value of shared_link set to null, i.e. {\"shared_link\": null}",
      "inputSchema": {
        "type": "object",
        "properties": {
          "FILE_ID": {
            "type": "string"
          },
          "body": {
            "$ref": "#/definitions/BoxFile"
          },
          "If-Match": {
            "type": "string",
            "description": "The etag of the file can be included as an ‘If-Match’ header to prevent race conditions."
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/BoxFile"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "getFileCollaborations",
      "title": "getFileCollaborations",
      "description": "Use this to get a list of all the collaborations on a file",
      "inputSchema": {
        "type": "object",
        "properties": {
          "FILE_ID": {
            "type": "string"
          },
          "fields": {
            "type": "string",
            "description": "Attribute(s) to include in the response"
          },
          "limit": {
            "type": "integer",
            "format": "int32",
            "description": "The maximum number of items to return in a page"
          },
          "offset": {
            "type": "integer",
            "format": "int32",
            "description": "The item at which to begin the response"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/CollaborationList"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "getFileComments",
      "title": "getFileComments",
      "description": "Retrieves the comments on a particular file, if any exist.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "FILE_ID": {
            "type": "string"
          },
          "fields": {
            "type": "string",
            "description": "Attribute(s) to include in the response"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/CommentList"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "getFileContent",
      "title": "getFileContent",
      "description": "Retrieves the actual data of the file. An optional version parameter can be set to download a previous version of the file.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "FILE_ID": {
            "type": "string"
          },
          "Range": {
            "type": "string",
            "description": "The range value in bytes. Format should be bytes={start_range}-{end_range}"
          },
          "version": {
            "type": "string",
            "description": "The ID specific version of this file to download."
          },
          "BoxApi": {
            "type": "string",
            "description": "The shared link for this item. Format should be shared_link=SHARED_LINK"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {},
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "copyFile",
      "title": "copyFile",
      "description": "Used to create a copy of a file in another folder. The original version of the file will not be altered.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "FILE_ID": {
            "type": "string"
          },
          "body": {
            "$ref": "#/definitions/CopyFile"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/BoxFile"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "getAllFileMetadata",
      "title": "getAllFileMetadata",
      "description": "Used to retrieve all metadata associated with a given file",
      "inputSchema": {
        "type": "object",
        "properties": {
          "FILE_ID": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/MetadataList"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "deleteFileMetadata",
      "title": "deleteFileMetadata",
      "description": "Used to delete the template instance. To delete custom key:value pairs within a template instance, you should refer to the updating metadata section.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "FILE_ID": {
            "type": "string"
          },
          "SCOPE": {
            "type": "string"
          },
          "TEMPLATE": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {},
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "getFileMetadata",
      "title": "getFileMetadata",
      "description": "Used to retrieve the metadata template instance for a corresponding Box file.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "FILE_ID": {
            "type": "string"
          },
          "SCOPE": {
            "type": "string"
          },
          "TEMPLATE": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/Metadata"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "createFileMetadata",
      "title": "createFileMetadata",
      "description": "Used to create the metadata template instance for a corresponding Box file. When creating metadata, only values that adhere to the metadata template schema will be accepted.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "FILE_ID": {
            "type": "string"
          },
          "SCOPE": {
            "type": "string"
          },
          "TEMPLATE": {
            "type": "string"
          },
          "body": {
            "$ref": "#/definitions/Metadata"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/Metadata"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "updateFileMetadata",
      "title": "updateFileMetadata",
      "description": "Used to update the template instance. The request body must follow the JSON-Patch specification, which is represented as a JSON array of operation objects (see examples for more details). Updates can be either add, replace, remove , test, move, or copy. The template instance can only be updated if the template instance already exists. When editing metadata, only values that adhere to the metadata template schema will be accepted.\nThe update is applied atomically. If any errors occur during the application of the update operations, the metadata instance remains unchanged.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "FILE_ID": {
            "type": "string"
          },
          "SCOPE": {
            "type": "string"
          },
          "TEMPLATE": {
            "type": "string"
          },
          "body": {
            "$ref": "#/definitions/UpdateMetadata"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/Metadata"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "getFileTasks",
      "title": "getFileTasks",
      "description": "Retrieves all of the tasks for given file.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "FILE_ID": {
            "type": "string"
          },
          "fields": {
            "type": "string",
            "description": "Attribute(s) to include in the response"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/TaskList"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "getFileThumbnail",
      "title": "getFileThumbnail",
      "description": "Retrieves a thumbnail, or smaller image representation, of this file. Sizes of 32x32,64x64, 128x128, and 256x256 can be returned in the .png format and sizes of 32x32, 94x94, 160x160, and 320x320 can be returned in the .jpg format. Thumbnails can be generated for the image and video file formats listed here.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "FILE_ID": {
            "type": "string"
          },
          "EXTENSION": {
            "type": "string",
            "description": "The preview format, e.g. png or jpg"
          },
          "min_height": {
            "type": "integer",
            "format": "int64",
            "description": "The minimum height of the thumbnail"
          },
          "min_width": {
            "type": "integer",
            "format": "int64",
            "description": "The minimum width of the thumbnail"
          },
          "max_height": {
            "type": "integer",
            "format": "int64",
            "description": "The maximum height of the thumbnail"
          },
          "max_width": {
            "type": "integer",
            "format": "int64",
            "description": "The maximum width of the thumbnail"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/BoxFile"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "deleteTrashedFile",
      "title": "deleteTrashedFile",
      "description": "Permanently deletes an item that is in the trash. The item will no longer exist in Box. This action cannot be undone.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "FILE_ID": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {},
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "getTrashedFile",
      "title": "getTrashedFile",
      "description": "Retrieves an item that has been moved to the trash.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "FILE_ID": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/BoxFile"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "getFileVersions",
      "title": "getFileVersions",
      "description": "If there are previous versions of this file, this method can be used to retrieve information about the older versions. (Versions are only tracked for Box users with premium accounts.)",
      "inputSchema": {
        "type": "object",
        "properties": {
          "FILE_ID": {
            "type": "string"
          },
          "fields": {
            "type": "string",
            "description": "Attribute(s) to include in the response"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/FileVersionList"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "promotoeFileVersion",
      "title": "promotoeFileVersion",
      "description": "If there are previous versions of this file, this method can be used to promote one of the older versions to the top of the stack. This actually mints a copy of the old version and puts it on the top of the versions stack. The file will have the exact same contents, the same SHA1/etag, and the same name as the original. Other properties such as comments do not get updated to their former values.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "FILE_ID": {
            "type": "string"
          },
          "body": {
            "$ref": "#/definitions/Reference"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/FileVersion"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "deleteFileVersion",
      "title": "deleteFileVersion",
      "description": "Discards a specific file version to the trash. (Depending on the enterprise settings for this user, the item will either be actually deleted from Box or moved to the trash.)",
      "inputSchema": {
        "type": "object",
        "properties": {
          "FILE_ID": {
            "type": "string"
          },
          "VERSION_ID": {
            "type": "string"
          },
          "If-Match": {
            "type": "string",
            "description": "The etag of the file. This is in the ‘etag’ field of the file object."
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {},
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "deleteFileWatermark",
      "title": "deleteFileWatermark",
      "description": "Used to remove the watermark for a corresponding Box file.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "FILE_ID": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/Watermark"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "getFileWatermark",
      "title": "getFileWatermark",
      "description": "Used to retrieve the watermark for a corresponding Box file.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "FILE_ID": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/Watermark"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "updateFileWatermark",
      "title": "updateFileWatermark",
      "description": "Used to apply or update the watermark for a corresponding Box file. The endpoint accepts a JSON body describing the watermark to apply.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "FILE_ID": {
            "type": "string"
          },
          "body": {
            "$ref": "#/definitions/Watermark"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/Watermark"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "createFolder",
      "title": "createFolder",
      "description": "Used to create a new empty folder. The new folder will be created inside of the specified parent folder",
      "inputSchema": {
        "type": "object",
        "properties": {
          "fields": {
            "type": "string",
            "description": "Attribute(s) to include in the response"
          },
          "body": {
            "$ref": "#/definitions/Folder"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/Folder"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "getTrashedItems",
      "title": "getTrashedItems",
      "description": "Retrieves the files and/or folders that have been moved to the trash. Any attribute in the full files or folders objects can be passed in with the fields parameter to get specific attributes, and only those specific attributes back; otherwise, the mini format is returned for each item by default. Multiple attributes can be passed in separated by commas e.g. fields=name,created_at. Paginated results can be retrieved using the limit and offset parameters.",
      "inputSchema": {
        "type": [
          "object",
          "null"
        ],
        "properties": {
          "fields": {
            "type": "string",
            "description": "Attribute(s) to include in the response"
          },
          "limit": {
            "type": "integer",
            "format": "int64",
            "description": "The maximum number of items to return"
          },
          "offset": {
            "type": "integer",
            "format": "int64",
            "description": "The item at which to begin the response"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/FileReferenceList"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "deleteFolder",
      "title": "deleteFolder",
      "description": "Used to delete a folder. A recursive parameter must be included in order to delete folders that have items inside of them. An optional If-Match header can be included to ensure that client only deletes the folder if it knows about the latest version.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "FOLDER_ID": {
            "type": "string"
          },
          "recursive": {
            "type": "boolean"
          },
          "If-Match": {
            "type": "string",
            "description": "This is in the ‘etag’ field of the folder object."
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {},
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "getFolder",
      "title": "getFolder",
      "description": "Retrieves the full metadata about a folder, including information about when it was last updated as well as the files and folders contained in it. The root folder of a Box account is always represented by the id “0”.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "fields": {
            "type": "string",
            "description": "Attribute(s) to include in the response"
          },
          "FOLDER_ID": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/Folder"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "restoreTrashedFolder",
      "title": "restoreTrashedFolder",
      "description": "Restores an item that has been moved to the trash. Default behavior is to restore the item to the folder it was in before it was moved to the trash. If that parent folder no longer exists or if there is now an item with the same name in that parent folder, the new parent folder and/or new name will need to be included in the request.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "FOLDER_ID": {
            "type": "string"
          },
          "fields": {
            "type": "string",
            "description": "Attribute(s) to include in the response"
          },
          "body": {
            "$ref": "#/definitions/Folder"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/Folder"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "updateFolder",
      "title": "updateFolder",
      "description": "Used to update information about the folder. To move a folder, update the ID of its parent. To enable an email address that can be used to upload files to this folder, update the folder_upload_email attribute. An optional If-Match header can be included to ensure that client only updates the folder if it knows about the latest version.\n\nUsed to create a shared link for this particular folder. Please see here for more information on the permissions available for shared links. In order to get default shared link status, set it to an empty access level, i.e. {\"shared_link\": {}}. In order to disable a shared link, send this same type of PUT request with the value of shared_link set to null, i.e. {\"shared_link\": null}\n\nTo add or remove an item from a collection, you do a PUT on that item and change the list of collections it belongs to. Philosophically, this is similar to the way “move” operations work on files and folders: you do a PUT on the item and change its parent. It’s the same idea with collections, except you’re changing which collection(s) the item belongs to instead of the folder it belongs to. Currently the only collection available is the favorites collection, and you’ll need to know it’s ID for the user that is making the API call, since every user has a different favorites collection_id.\nThe Add/Remove API handling will check all ids passed in before performing any add/removal operations. If any collection ids are malformed or do not exist in the user’s account, the API call will throw a 400. Only if all of the collection ids are valid will the adds and removals be carried out.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "FOLDER_ID": {
            "type": "string"
          },
          "fields": {
            "type": "string",
            "description": "Attribute(s) to include in the response"
          },
          "body": {
            "$ref": "#/definitions/Folder"
          },
          "If-Match": {
            "type": "string",
            "description": "This is in the ‘etag’ field of the folder object."
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/Folder"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "getFolderCollaborations",
      "title": "getFolderCollaborations",
      "description": "Use this to get a list of all the collaborations on a folder i.e. all of the users that have access to that folder.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "FOLDER_ID": {
            "type": "string"
          },
          "fields": {
            "type": "string",
            "description": "Attribute(s) to include in the response"
          },
          "limit": {
            "type": "integer",
            "format": "int64",
            "description": "The maximum number of items to return in a page. The default is 100 and the max is 1000."
          },
          "offset": {
            "type": "integer",
            "format": "int64",
            "description": "The item at which to begin the response"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/CollaborationList"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "copyFolder",
      "title": "copyFolder",
      "description": "Used to create a copy of a folder in another folder. The original version of the folder will not be altered.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "FOLDER_ID": {
            "type": "string"
          },
          "fields": {
            "type": "string",
            "description": "Attribute(s) to include in the response"
          },
          "body": {
            "$ref": "#/definitions/Folder"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/Folder"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "getFolderItems",
      "title": "getFolderItems",
      "description": "Retrieves the files and/or folders contained within this folder without any other metadata about the folder. Any attribute in the full files or folders objects can be passed in with the fields parameter to get specific attributes, and only those specific attributes back; otherwise, the mini format is returned for each item by default. Multiple attributes can be passed in separated by commas e.g. fields=name,created_at. Paginated results can be retrieved using the limit and offset parameters.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "FOLDER_ID": {
            "type": "string"
          },
          "fields": {
            "type": "string",
            "description": "Attribute(s) to include in the response"
          },
          "limit": {
            "type": "integer",
            "format": "int64",
            "description": "The maximum number of items to return in a page. The default is 100 and the max is 1000."
          },
          "offset": {
            "type": "string",
            "description": "The offset at which to begin the response. An offset of value of 0 will start at the beginning of the folder-listing. Note: If there are hidden items in your previous response, your next offset should be = offset + limit, not the # of records you received back. The default is 0."
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/ItemReferenceList"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "getAllFolderMetadata",
      "title": "getAllFolderMetadata",
      "description": "Used to retrieve all metadata associated with a given folder",
      "inputSchema": {
        "type": "object",
        "properties": {
          "FOLDER_ID": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/MetadataList"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "deleteFolderMetadata",
      "title": "deleteFolderMetadata",
      "description": "Used to delete the template instance. To delete custom key:value pairs within a template instance, you should refer to the updating metadata section.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "FOLDER_ID": {
            "type": "string"
          },
          "SCOPE": {
            "type": "string"
          },
          "TEMPLATE": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {},
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "getFolderMetadata",
      "title": "getFolderMetadata",
      "description": "Used to retrieve the metadata template instance for a corresponding Box folder.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "FOLDER_ID": {
            "type": "string"
          },
          "SCOPE": {
            "type": "string"
          },
          "TEMPLATE": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/Metadata"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "createFolderMetadata",
      "title": "createFolderMetadata",
      "description": "Used to create the metadata template instance for a corresponding Box folder. When creating metadata, only values that adhere to the metadata template schema will be accepted.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "FOLDER_ID": {
            "type": "string"
          },
          "SCOPE": {
            "type": "string"
          },
          "TEMPLATE": {
            "type": "string"
          },
          "body": {
            "$ref": "#/definitions/Metadata"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/Metadata"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "updateFolderMetadata",
      "title": "updateFolderMetadata",
      "description": "Used to update the template instance. Updates can be either add, replace, remove , or test. The template instance can only be updated if the template instance already exists. When editing metadata, only values that adhere to the metadata template schema will be accepted.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "FOLDER_ID": {
            "type": "string"
          },
          "SCOPE": {
            "type": "string"
          },
          "TEMPLATE": {
            "type": "string"
          },
          "body": {
            "$ref": "#/definitions/UpdateMetadata"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/Metadata"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "deleteTrashedFolder",
      "title": "deleteTrashedFolder",
      "description": "Permanently deletes an folder that is in the trash. The item will no longer exist in Box. This action cannot be undone.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "FOLDER_ID": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {},
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "getTrashedFolder",
      "title": "getTrashedFolder",
      "description": "Retrieves an folder that has been moved to the trash.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "FOLDER_ID": {
            "type": "string"
          },
          "fields": {
            "type": "string",
            "description": "Attribute(s) to include in the response"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/Folder"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "deleteFolderWatermark",
      "title": "deleteFolderWatermark",
      "description": "Used to remove the watermark for a corresponding Box Folder.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "FOLDER_ID": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/Watermark"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "getFolderWatermark",
      "title": "getFolderWatermark",
      "description": "Used to retrieve the watermark for a corresponding Box folder.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "FOLDER_ID": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/Watermark"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "updateFolderWatermark",
      "title": "updateFolderWatermark",
      "description": "Used to apply or update the watermark for a corresponding Box folder. The endpoints accepts a JSON body describing the watermark to apply.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "FOLDER_ID": {
            "type": "string"
          },
          "body": {
            "$ref": "#/definitions/Watermark"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/Watermark"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "createGroupMembership",
      "title": "createGroupMembership",
      "description": "Used to add a member to a Group.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "fields": {
            "type": "string",
            "description": "Attribute(s) to include in the response"
          },
          "body": {
            "$ref": "#/definitions/GroupMembership"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/GroupMembership"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "deleteGroupMembership",
      "title": "deleteGroupMembership",
      "description": "Deletes a specific group membership.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "GROUP_MEMBERSHIP_ID": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {},
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "getGroupMembership",
      "title": "getGroupMembership",
      "description": "Fetches a specific group membership entry.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "GROUP_MEMBERSHIP_ID": {
            "type": "string"
          },
          "fields": {
            "type": "string",
            "description": "Attribute(s) to include in the response"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/GroupMembership"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "updateGroupMembership",
      "title": "updateGroupMembership",
      "description": "Used to update a group membership.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "GROUP_MEMBERSHIP_ID": {
            "type": "string"
          },
          "fields": {
            "type": "string",
            "description": "Attribute(s) to include in the response"
          },
          "body": {
            "$ref": "#/definitions/GroupMembership"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/GroupMembership"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "getEnterpriseGroups",
      "title": "getEnterpriseGroups",
      "description": "Retrieves all of the groups for given enterprise. Must have permissions to see an enterprise's groups.",
      "inputSchema": {
        "type": [
          "object",
          "null"
        ],
        "properties": {
          "fields": {
            "type": "string",
            "description": "Attribute(s) to include in the response"
          },
          "limit": {
            "type": "integer",
            "format": "int64",
            "description": "The maximum number of items to return in a page. The default is 100 and the max is 1000."
          },
          "offset": {
            "type": "integer",
            "format": "int64",
            "description": "The item at which to begin the response."
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/GroupList"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "createGroup",
      "title": "createGroup",
      "description": "Used to create a group.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "fields": {
            "type": "string",
            "description": "Attribute(s) to include in the response"
          },
          "body": {
            "$ref": "#/definitions/Group"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/Group"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "deleteGroup",
      "title": "deleteGroup",
      "description": "Permanently deletes a specific group.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "GROUP_ID": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {},
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "getGroup",
      "title": "getGroup",
      "description": "Used to get information about a group.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "GROUP_ID": {
            "type": "string"
          },
          "fields": {
            "type": "string",
            "description": "Attribute(s) to include in the response"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/Group"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "updateGroup",
      "title": "updateGroup",
      "description": "Updates a specific group.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "GROUP_ID": {
            "type": "string"
          },
          "fields": {
            "type": "string",
            "description": "Attribute(s) to include in the response"
          },
          "body": {
            "$ref": "#/definitions/Group"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/Group"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "getGroupCollaborations",
      "title": "getGroupCollaborations",
      "description": "Retrieves all of the group collaborations for a given group. Note this is only available to group admins.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "GROUP_ID": {
            "type": "string"
          },
          "fields": {
            "type": "string",
            "description": "Attribute(s) to include in the response"
          },
          "limit": {
            "type": "integer",
            "format": "int64",
            "description": "The maximum number of items to return in a page. The default is 100 and the max is 1000."
          },
          "offset": {
            "type": "integer",
            "format": "int64",
            "description": "The item at which to begin the response."
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/CollaborationList"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "getGroupMemberships",
      "title": "getGroupMemberships",
      "description": "Retrieves all of the members for a given group if the requesting user has access (see Group Object member_viewability_level).",
      "inputSchema": {
        "type": "object",
        "properties": {
          "GROUP_ID": {
            "type": "string"
          },
          "fields": {
            "type": "string",
            "description": "Attribute(s) to include in the response"
          },
          "limit": {
            "type": "integer",
            "format": "int64",
            "description": "The maximum number of items to return in a page. The default is 100 and the max is 1000."
          },
          "offset": {
            "type": "integer",
            "format": "int64",
            "description": "The item at which to begin the response."
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/GroupMembershipList"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "createInvite",
      "title": "createInvite",
      "description": "Invites an existing user to join an Enterprise. The existing user can not be part of another Enterprise and must already have a Box account. Once invited, the user will receive an email and prompt to accept the invitation within the Box web application. This method requires the \"Manage An Enterprise\" scope for the enterprise, which can be enabled within your developer console.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "fields": {
            "type": "string",
            "description": "Attribute(s) to include in the response"
          },
          "body": {
            "$ref": "#/definitions/InviteUser"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/Invite"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "getInvite",
      "title": "getInvite",
      "description": "Get status of the invite",
      "inputSchema": {
        "type": "object",
        "properties": {
          "INVITE_ID": {
            "type": "string"
          },
          "fields": {
            "type": "string",
            "description": "Attribute(s) to include in the response"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/Invite"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "getLegalHoldPolicies",
      "title": "getLegalHoldPolicies",
      "description": "Get a list of Legal Hold Policies that belong to your Enterprise.",
      "inputSchema": {
        "type": [
          "object",
          "null"
        ],
        "properties": {
          "policy_name": {
            "type": "string",
            "description": "Case insensitive prefix-match filter on Policy name."
          },
          "limit": {
            "type": "integer",
            "format": "int32",
            "description": "Limit result size to this number. Defaults to 100, maximum is 1,000."
          },
          "marker": {
            "type": "string",
            "description": "Take from next_marker column of a prior call to get the next page"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/LegalHoldPolicyList"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "createLegalHoldPolicy",
      "title": "createLegalHoldPolicy",
      "description": "Create a new Legal Hold Policy. Optional date filter may be passed. If Policy has a date filter, any Custodian assignments will apply only to file versions created or uploaded inside of the date range.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "body": {
            "$ref": "#/definitions/LegalHoldPolicy"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/LegalHoldPolicy"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "deleteLegalHoldPolicy",
      "title": "deleteLegalHoldPolicy",
      "description": "Sends request to delete an existing Legal Hold Policy. Note that this is an asynchronous process - the Policy will not be fully deleted yet when the response comes back.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "ID": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {},
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "getLegalHoldPolicy",
      "title": "getLegalHoldPolicy",
      "description": "Get details of a single Legal Hold Policy",
      "inputSchema": {
        "type": "object",
        "properties": {
          "ID": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/LegalHoldPolicy"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "updateLegalHoldPolicy",
      "title": "updateLegalHoldPolicy",
      "description": "Update existing Legal Hold Policy. Only name and description can be modified.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "ID": {
            "type": "string"
          },
          "body": {
            "$ref": "#/definitions/LegalHoldPolicy"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/LegalHoldPolicy"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "getLegalHoldPolicyAssignments",
      "title": "getLegalHoldPolicyAssignments",
      "description": "Get list of assignments for a single Policy.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "ID": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/LegalHoldPolicyAssignmentList"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "createLegalHoldPolicyAssignment",
      "title": "createLegalHoldPolicyAssignment",
      "description": "Create a new Assignment, which will apply the Legal Hold Policy to the target of the Assignment.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "body": {
            "$ref": "#/definitions/CreateLegalHoldPolicyAssignment"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/LegalHoldPolicyAssignment"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "deleteLegalHoldPolicyAssignment",
      "title": "deleteLegalHoldPolicyAssignment",
      "description": "Sends request to delete an existing Assignment. Note that this is an asynchronous process - the Assignment will not be fully deleted yet when the response comes back.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "ASSIGNMENT_ID": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {},
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "getLegalHoldPolicyAssignment",
      "title": "getLegalHoldPolicyAssignment",
      "description": "Get details of a single assignment.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "ASSIGNMENT_ID": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {},
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "createMetadataTemplate",
      "title": "createMetadataTemplate",
      "description": "Used to create a new metadata template with the specified schema.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "body": {
            "$ref": "#/definitions/MetadataTemplate"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/MetadataTemplate"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "getEnterpriseMetadataTemplates",
      "title": "getEnterpriseMetadataTemplates",
      "description": "Used to retrieve all metadata templates within a user's enterprise. Currently only the enterprise scope is supported.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "SCOPE": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/MetadataTemplateList"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "getMetadataTemplate",
      "title": "getMetadataTemplate",
      "description": "Used to retrieve the schema for a given metadata template.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "SCOPE": {
            "type": "string"
          },
          "TEMPLATE": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/MetadataTemplate"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "updateMetadataTemplate",
      "title": "updateMetadataTemplate",
      "description": "Used to update the schema of an existing template.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "SCOPE": {
            "type": "string"
          },
          "TEMPLATE": {
            "type": "string"
          },
          "body": {
            "$ref": "#/definitions/UpdateMetadataTemplate"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/MetadataTemplate"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "getRetentionPolicies",
      "title": "getRetentionPolicies",
      "description": "Retrieves all of the retention policies for the given enterprise.",
      "inputSchema": {
        "type": [
          "object",
          "null"
        ],
        "properties": {
          "policy_name": {
            "type": "string",
            "description": "A name to filter the retention policies by. A trailing partial match search is performed."
          },
          "policy_type": {
            "type": "string",
            "description": "A policy type to filter the retention policies by.",
            "enum": [
              "finite",
              "indefinite"
            ]
          },
          "created_by_user_id": {
            "type": "string",
            "description": "A user id to filter the retention policies by."
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/RetentionPolicyList"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "createRetentionPolicy",
      "title": "createRetentionPolicy",
      "description": "Used to create a new retention policy.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "body": {
            "$ref": "#/definitions/RetentionPolicy"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/RetentionPolicy"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "getRetentionPolicy",
      "title": "getRetentionPolicy",
      "description": "Used to retrieve information about a retention policy",
      "inputSchema": {
        "type": "object",
        "properties": {
          "POLICY_ID": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/RetentionPolicy"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "updateRetentionPolicy",
      "title": "updateRetentionPolicy",
      "description": "Used to update a retention policy.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "POLICY_ID": {
            "type": "string"
          },
          "body": {
            "$ref": "#/definitions/RetentionPolicy"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/RetentionPolicy"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "getRetentionPolicyAssignments",
      "title": "getRetentionPolicyAssignments",
      "description": "Returns a list of all retention policy assignments associated with a specified retention policy.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "POLICY_ID": {
            "type": "string"
          },
          "type": {
            "type": "string",
            "description": "The type of the retention policy assignment to retrieve. Can either be folder or enterprise.",
            "enum": [
              "folder",
              "enterprise"
            ]
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/RetentionPolicyAssignmentList"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "createRetentionPolicyAssignment",
      "title": "createRetentionPolicyAssignment",
      "description": "Returns a list of all retention policy assignments associated with a specified retention policy.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "body": {
            "$ref": "#/definitions/CreateRetentionPolicyAssignment"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/RetentionPolicyAssignment"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "getRetentionPolicyAssignment",
      "title": "getRetentionPolicyAssignment",
      "description": "Used to retrieve information about a retention policy assignment.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "RETENTION_POLICY_ASSIGNMENT_ID": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/RetentionPolicyAssignment"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "search",
      "title": "search",
      "description": "The search endpoint provides a powerful way of finding items that are accessible by a single user or an entire enterprise. Leverage the parameters listed below to generate targeted advanced searches.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "query": {
            "type": "string",
            "description": "The string to search for; can be matched against item names, descriptions, text content of a file, and other fields of the different item types."
          },
          "scope": {
            "type": "string",
            "description": "The scope for which you want to limit your search to. Can be user_content for a search limited to only the current user or enterprise_content for the entire enterprise. To enable the enterprise_content scope for an administrator, please contact us."
          },
          "file_extensions": {
            "type": "string",
            "description": "Limit searches to specific file extensions like pdf,png,doc. Requires one or a set of comma delimited file extensions: file_extension_1,file_extension_2,...."
          },
          "created_at_range": {
            "type": "string",
            "format": "date-time",
            "description": "The date for when the item was created. Specify the date range by using RFC3339 timestamp variables separated by a comma: from_date,to_date (e.g 2014-05-15T13:35:01-07:00,2014-05-17T13:35:01-07:00). Trailing from_date, and leading ,to_date commas are also accepted, where the current date and earliest known date will be designated respectively."
          },
          "updated_at_range": {
            "type": "string",
            "format": "date-time",
            "description": "The date for when the item was last updated. Specify the date range by using RFC3339 variables separated by a comma: from_date,to_date(e.g 2014-05-15T13:35:01-07:00,2014-05-17T13:35:01-07:00). Trailing from_date, and leading ,to_date commas are also accepted, where the current date and earliest known date will be designated respectively."
          },
          "size_range": {
            "type": "integer",
            "format": "int64",
            "description": "Filter by a file size range. Specify the file size range in bytes separated by a comma:lower_bound_size,upper_bound_size, where 1MB is equivalent to 1000000 bytes. Trailing lower_bound_size, and leading ,upper_bound_size commas are also accepted as parameters."
          },
          "owner_user_ids": {
            "type": "string",
            "description": "Search by item owners. Requires one or a set of comma delimited user_ids: user_id_1,user_id_2,..."
          },
          "ancestor_folder_ids": {
            "type": "string",
            "description": "Limit searches to specific parent folders. Requires one or a set of comma delimited folder_ids: folder_id_1,folder_id_2,.... Parent folder results will also include items within subfolders."
          },
          "content_types": {
            "type": "string",
            "description": "Limit searches to specific Box designated content types. Can be name, description, file_content, comments, or tags. Requires one or a set of comma delimited content_types: content_type_1,content_type_2,...."
          },
          "type": {
            "type": "string",
            "description": "The type you want to return in your search. Can be file, folder, or web_link.",
            "enum": [
              "file",
              "folder",
              "web_link"
            ]
          },
          "trash_content": {
            "type": "string",
            "description": "Allows you to search within the trash. Can be trashed_only or non_trashed_only. Searches without this parameter default to non_trashed_only."
          },
          "mdfilters": {
            "type": "string",
            "description": "Filters for a specific metadata template for files with metadata object associations. The filters are to be placed in a single JSON object. Please refer the MDFilters object in the definitions section of the swagger.json"
          },
          "limit": {
            "type": "integer",
            "format": "int64",
            "description": "Number of search results to return. The default is 30 and the max is 200."
          },
          "offset": {
            "type": "integer",
            "format": "int64",
            "description": "The search result at which to start the response. The default is 0."
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/ObjectList"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "getSharedItems",
      "title": "getSharedItems",
      "description": "Shared items are any files or folders that are represented by a shared link. Shared items are different from other API resources in that a shared resource doesn’t necessarily have to be in the account of the user accessing it. The actual shared link itself is used along with a normal access token.\nUsed to retrieve the metadata about a shared item when only given a shared link. Because of varying permission for shared links, a password may be required to retrieve the shared item. Once the item has been retrieved, you can make API requests against the actual resource /files/{id} or /folders/{id} as long as the shared link and optional password are in the header.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "BoxApi": {
            "type": "string",
            "description": "The usage is 'BoxApi: shared_link=SHARED_LINK&shared_link_password=SHARED_LINK_PASSWORD'"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "type": "object"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "createTaskAssignment",
      "title": "createTaskAssignment",
      "description": "Used to assign a task to a single user. There can be multiple assignments on a given task.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "body": {
            "$ref": "#/definitions/CreateTaskAssignment"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/TaskAssignment"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "deleteTaskAssignment",
      "title": "deleteTaskAssignment",
      "description": "Deletes a specific task assignment.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "TASK_ASSIGNMENT_ID": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {},
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "getTaskAssignment",
      "title": "getTaskAssignment",
      "description": "Fetches a specific task assignment.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "TASK_ASSIGNMENT_ID": {
            "type": "string"
          },
          "fields": {
            "type": "string",
            "description": "Attribute(s) to include in the response"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/TaskAssignment"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "updateTaskAssignment",
      "title": "updateTaskAssignment",
      "description": "Used to update a task assignment.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "TASK_ASSIGNMENT_ID": {
            "type": "string"
          },
          "body": {
            "$ref": "#/definitions/TaskAssignment"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/TaskAssignment"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "createTask",
      "title": "createTask",
      "description": "Used to create a single task for single user on a single file.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "body": {
            "$ref": "#/definitions/Task"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/Task"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "deleteTask",
      "title": "deleteTask",
      "description": "Permanently deletes a specific task.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "TASK_ID": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {},
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "getTask",
      "title": "getTask",
      "description": "Fetches a specific task.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "TASK_ID": {
            "type": "string"
          },
          "fields": {
            "type": "string",
            "description": "Attribute(s) to include in the response"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/Task"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "updateTask",
      "title": "updateTask",
      "description": "Updates a specific task.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "TASK_ID": {
            "type": "string"
          },
          "fields": {
            "type": "string",
            "description": "Attribute(s) to include in the response"
          },
          "body": {
            "$ref": "#/definitions/Task"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/Task"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "getTaskAssignments",
      "title": "getTaskAssignments",
      "description": "Retrieves all of the assignments for a given task.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "TASK_ID": {
            "type": "string"
          },
          "fields": {
            "type": "string",
            "description": "Attribute(s) to include in the response"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/TaskAssignmentList"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "getEnterpriseUsers",
      "title": "getEnterpriseUsers",
      "description": "Returns a list of all users for the Enterprise along with their user_id, public_name, and login.",
      "inputSchema": {
        "type": [
          "object",
          "null"
        ],
        "properties": {
          "fields": {
            "type": "string",
            "description": "Attribute(s) to include in the response"
          },
          "filter_term": {
            "type": "string",
            "description": "A string used to filter the results to only users starting with the filter_term in either the name or the login."
          },
          "limit": {
            "type": "integer",
            "format": "int64",
            "description": "The number of records to return. The default is 100 and the max is 1000."
          },
          "offset": {
            "type": "integer",
            "format": "int64",
            "description": "The record at which to start. The default is 0."
          },
          "user_type": {
            "type": "string",
            "description": "The type of user to search for. Valid values are all, external or managed.  If nothing is provided, the default behavior will be managed only",
            "enum": [
              "all",
              "external",
              "managed"
            ]
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/UserList"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "createUser",
      "title": "createUser",
      "description": "Used to provision a new user in an enterprise. This method only works for enterprise admins.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "fields": {
            "type": "string",
            "description": "Attribute(s) to include in the response"
          },
          "body": {
            "$ref": "#/definitions/User"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/User"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "getCurrentUser",
      "title": "getCurrentUser",
      "description": "Retrieves information about the user who is currently logged in i.e. the user for whom this auth token was generated.",
      "inputSchema": {
        "type": [
          "object",
          "null"
        ],
        "properties": {
          "fields": {
            "type": "string",
            "description": "Attribute(s) to include in the response"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/User"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "deleteUser",
      "title": "deleteUser",
      "description": "Deletes a user in an enterprise account.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "USER_ID": {
            "type": "string"
          },
          "notify": {
            "type": "boolean"
          },
          "force": {
            "type": "boolean"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {},
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "getUser",
      "title": "getUser",
      "description": "Retrieves information about a user in the enterprise. Requires enterprise administration authorization.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "USER_ID": {
            "type": "string"
          },
          "fields": {
            "type": "string",
            "description": "Attribute(s) to include in the response"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/User"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "updateUser",
      "title": "updateUser",
      "description": "Used to edit the settings and information about a user. This method only works for enterprise admins. To roll a user out of the enterprise (and convert them to a standalone free user), update the special enterprise attribute to be null.\n\nUsed to convert one of the user’s confirmed email aliases into the user’s primary login.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "USER_ID": {
            "type": "string"
          },
          "fields": {
            "type": "string",
            "description": "Attribute(s) to include in the response"
          },
          "body": {
            "$ref": "#/definitions/User"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/User"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "getEmailAliases",
      "title": "getEmailAliases",
      "description": "Retrieves all email aliases for this user. The collection of email aliases does not include the primary login for the user; use GET /users/USER_ID to retrieve the login email address.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "USER_ID": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/EmailAliasList"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "addEmailAlias",
      "title": "addEmailAlias",
      "description": "Adds a new email alias to the given user’s account.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "USER_ID": {
            "type": "string"
          },
          "body": {
            "$ref": "#/definitions/EmailAlias"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/EmailAlias"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "deleteUserEmailAlias",
      "title": "deleteUserEmailAlias",
      "description": "Removes an email alias from a user.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "USER_ID": {
            "type": "string"
          },
          "EMAIL_ALIAS_ID": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {},
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "updateUserFolder",
      "title": "updateUserFolder",
      "description": "Moves all of the owned content from within one user’s folder into a new folder in another user’s account. You can move folders across users as long as the you have administrative permissions and the ‘source’ user owns the folders. To move everything from the root folder, use “0” which always represents the root folder of a Box account.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "USER_ID": {
            "type": "string"
          },
          "FOLDER_ID": {
            "type": "string"
          },
          "notify": {
            "type": "boolean"
          },
          "fields": {
            "type": "string",
            "description": "Attribute(s) to include in the response"
          },
          "body": {
            "$ref": "#/definitions/Folder"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/Folder"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "getUserGroupMembership",
      "title": "getUserGroupMembership",
      "description": "Retrieves all of the group memberships for a given user. Note this is only available to group admins. To retrieve group memberships for the user making the API request, use the users/me/memberships endpoint.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "USER_ID": {
            "type": "string"
          },
          "fields": {
            "type": "string",
            "description": "Attribute(s) to include in the response"
          },
          "limit": {
            "type": "integer",
            "format": "int64",
            "description": "Default is 100. Max is 1000"
          },
          "offset": {
            "type": "integer",
            "format": "int64",
            "description": "The item at which to begin the response"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/GroupMembershipList"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "createWebLink",
      "title": "createWebLink",
      "description": "Creates a web link object within a given folder.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "body": {
            "$ref": "#/definitions/WebLink"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/WebLink"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "deleteWebLink",
      "title": "deleteWebLink",
      "description": "Deletes a web link and moves it to the trash",
      "inputSchema": {
        "type": "object",
        "properties": {
          "WEB_LINK_ID": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {},
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "getWebLink",
      "title": "getWebLink",
      "description": "Use to get information about the web link.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "WEB_LINK_ID": {
            "type": "string"
          },
          "fields": {
            "type": "string",
            "description": "Attribute(s) to include in the response"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/WebLink"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "updateWebLink",
      "title": "updateWebLink",
      "description": "Updates information for a web link.",
      "inputSchema": {
        "type": "object",
        "properties": {
          "WEB_LINK_ID": {
            "type": "string"
          },
          "fields": {
            "type": "string",
            "description": "Attribute(s) to include in the response"
          },
          "body": {
            "$ref": "#/definitions/WebLink"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/WebLink"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "getWebhooks",
      "title": "getWebhooks",
      "description": "Returns all defined webhooks for the requesting application and user, up to the limit. If no limit is supplied then Box uses the default limit of 100.\nIf more than limit webhooks are defined then Box returns the webhooks in batches. When the results are batched, Box sends limit webhooks along with a next_marker field in the response object. The value of the next_marker field is a marker string that you can use in later requests to tell Box which batch to send next.\nWhen you send a request that includes a marker string, Box sends the next batch of webhooks, beginning after the last webhook of the previous batch. When the response contains the last of the defined webhooks, Box omits the next_marker field from its response.\nYou can use limit and marker together with the marker string returned in the next_marker field to paginate lists of webhooks.",
      "inputSchema": {
        "type": [
          "object",
          "null"
        ],
        "properties": {
          "limit": {
            "type": "integer",
            "format": "int64",
            "description": "The maximum number of webhooks to return per page"
          },
          "marker": {
            "type": "string",
            "description": "A marker string returned by Box if the result contains less than the full number of webhooks that are defined"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/WebhookList"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "createWebhook",
      "title": "createWebhook",
      "description": "Create Webhook",
      "inputSchema": {
        "type": "object",
        "properties": {
          "body": {
            "$ref": "#/definitions/Webhook"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/Webhook"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "deleteWebhook",
      "title": "deleteWebhook",
      "description": "Permanently deletes a webhook",
      "inputSchema": {
        "type": "object",
        "properties": {
          "WEBHOOK_ID": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {},
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "getWebhook",
      "title": "getWebhook",
      "description": "Get a Webhook",
      "inputSchema": {
        "type": "object",
        "properties": {
          "WEBHOOK_ID": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/Webhook"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    },
    {
      "id": "updateWebhook",
      "title": "updateWebhook",
      "description": "Update a Webhook",
      "inputSchema": {
        "type": "object",
        "properties": {
          "WEBHOOK_ID": {
            "type": "string"
          },
          "body": {
            "$ref": "#/definitions/Webhook"
          }
        },
        "additionalProperties": false
      },
      "outputSchema": {
        "$ref": "#/definitions/Webhook"
      },
      "security": {
        "box_content": {
          "integration": "box_content"
        }
      }
    }
  ]
}